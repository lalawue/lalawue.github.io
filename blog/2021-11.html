<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>Sucha's Blog - Archive for November, 2021</title>
    <meta name="generator" content="MarkdownProjectCompositor.lua" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="Sucha" />
    <meta name="keywords" content="suchang, programming, GNU, Linux, Emacs, Lua" />
    <meta name="description" content="Sucha's blog" />
    <link rev="made" href="mailto:suchaaa@gmail.com" />
    <link rel="shortcut icon" href="../images/ico.png" />
    <link rel="stylesheet" type="text/css" href="../styles/blog.css" />
  </head>
  <body>
    <div id="body">
      <div id="text">
	   <!-- Page published by cmark-gfm begins here --><h1>Sucha's Blog ~ Archive for November, 2021</h1>
<p><a id="p1"></a></p>
<div class="date">21年11月11日 周四 00:33</div>
<h2>Mithril 使用心得（1）</h2>
<p>这个网站已经诞生 10 多年，但其是静态页面，基于 XHTML 结构，而不是最新的 HTML5，站长本人是专业 APP 开发，
H5/Web 开发比较业余，对 <a href="https://mithril.js.org/">Mithril</a> 的使用感觉还不够深入，但也算趟了一些坑，
可以作为心得说一下的。</p>
<p>说一下为何不使用 React、Vue 或者 Preact，以及 Angular 等等其他框架，没什么原因，因为其实入手之前看了非常多的入门对比文章，
在对比的过程中总是要上手的嘛，因为看到 Mithril 吹自己简单，其网站入门教程的介绍也是非常到位的（React 没能一下学会，
但是 Mithril 可以），加上不需要 nodejs 这样的依赖，不需要 build，学习的曲线感觉很平缓。</p>
<p>话说我之前是一个连 SPA（Single Page Application）都不懂的人，通过 Mithril 的教程，学会了基础的 component，
route、以及 XHR，基本上一个单页面就可以搞定了。</p>
<p>再说还有 <a href="https://stackblitz.com/">stackblitz</a> 这样的平台，入门是很方便的。因为是个无需 build 的方案，
简单的 HTML5 + rel 标签带入 Mithril 就可以开始工作了。</p>
<p>js 我也只懂皮毛，很多东西都得百度，没关系，出来的程序能用就行。最后做了 2 个 SPA 页面，一个是 wiki，一个是 note 便签。</p>
<p>wiki 的相对简单一些，大概 2 - 3 天才搞定，学习了 route，但是内部的很多状态我是通过一个全局状态变量来控制的。
便签这个页面没有用到路由，纯内部状态跳转刷新，两个都没有用到 browser 的 history，浏览器的返回按钮会退回上个 URL。</p>
<p>Mithirl 的 bind 或者 route，都可以仅指定页面的一个部分，一个 element 来刷新，内部是根据 vnode 的变化来判断是否更新的，
这个 vnode 变化感觉有点悬乎，比如我在创建一些子节点的时候，attribute 是有变化的，但是 Mithril 感觉不到这个变化，
所以我不得不在外层做更明显的 vnode 变化，比如增加一个用不到的 span 标签这样，来确保重新输出 HTML 节点。</p>
<p>Mithril 限定 60hz 刷新确实也不错，但是遇到一些极端情况，比如自己本地测试的时候，网络返回就挺快的，当我在用内部变量控制
vnode 输出的不同时，因为间隔过短，虽然变量有切换状态，但 Mithril 间隔读取到的其实都是同一个状态下的 vnode，
而忽略了中间这个变量状态下 vnode 的输出，最后导致认为没有变化，不需要刷新，出了问题，如下：</p>
<pre lang="source"><code>// 如下的 A、B 表示变量值，后面数字表示 vnode 结构为 A 但内容不同，这里需要保证 A1 -&gt; B 间隔 1/60 秒
A1 -&gt; B -&gt; A2
</code></pre>
<p>所以有时候，需要将一些操作延时到 60hz 单次刷新之外才行，让 Mithril 检测到 vnode 变化。</p>
<p>Mithril 教程用的是古老的创建 vnode 的函数调用方案，但其实可以配合 preact 的 <a href="https://github.com/developit/htm">htm</a>，
我觉得使用方式上要比教程里面的简单很多，比如教程是下面这样创建 vnode 的：</p>
<pre lang="source"><code>// 下面 title_str 是变量
// &lt;h1 class=&quot;title&quot;&gt;My first app&lt;/h1&gt;
const title_str = 'title';
m(&quot;h1&quot;, {class: title_str}, &quot;My first app&quot;)
</code></pre>
<p>如果用了 <a href="https://github.com/developit/htm">htm</a>，可以像下面这样：</p>
<pre lang="source"><code>// 先绑定，最后也是通过 m 函数来输出 vnode 的
const html = htm.bind(m);
const title_str = 'title';
html`&lt;h1 class=&quot;${title_str}&quot;&gt;My first app&lt;/h1&gt;`
</code></pre>
<p>明显是使用了 htm 的代码更容易定位问题。</p>
<p>因为追求短平快，单个 js 文件就完成了 wiki 或者 note 便签这样的功能，所以 Mithril 结构化方面我是没有发言权了，教程上面
呼吁结构化组件，分解功能模块我是一点都没用上。</p>
<p>先这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-11.html#p1">Permalink</a></div>
<p><a id="p0"></a></p>
<div class="date">21年11月07日 周日 11:46</div>
<h2>stunnel 的 SNI 配置</h2>
<p>因为是很小的网站，资源也有限，感觉没必要用上 openresty 这个大件。</p>
<p>先贴配置：</p>
<pre lang="source"><code>debug=info
output=/path/to/access.log
pid=/path/to/process.pid
client=no

[https]
accept = 443
connect = 127.0.0.1:port1
cert = /path/to/default.cer
key = /path/to/default.key

[site1]
connect = 127.0.0.1:port1
sni = https:site1.domain
cert = /path/to/site1.cer
key = /path/to/site1.key

[site2]
connect = 127.0.0.1:port2
sni = https:*.site2.domain
cert = /path/to/site2.cer
key = /path/to/site2.key
</code></pre>
<p>说一下上面的配置。</p>
<p>这是类似 INI 方式的配置文件，首先定义是 server 端的配置，设置 access.log 和 process.pid 文件的位置。</p>
<p>之后设置默认协议，比如叫做 https，监听 443 端口，并设置连接地址，使用默认的 cert 和 key 做验证，这里其实是可以跟下面的 site1 或者 site2 用同样的 cert 和 key 配置。</p>
<p>之后分别设置不同网站对应的处理地址，比如 site1，连接的是 port1，注意 sni 字段配置，第一个是协议，就是上面描述过的 https，而不是 HTTPS，之后是需要处理的 domain，这里只处理二级域名，没有通配字，最后加入网站申请到的 cert 和 key。</p>
<p>site2 的 sni 用了通配字，所有 site2.domain 的二级、三级域名都可通过验证处理。</p>
<div class="category"><a href="CategoryLinux.html">CategoryLinux</a> / <a href="2021-11.html#p0">Permalink</a></div>
<!-- Page published by cmark-gfm ends here -->
  <div id="foot">2004-<script type="text/javascript">var d = new
	Date();document.write(d.getFullYear())</script> &copy;
	Sucha. Powered by MarkdownProjectCompositor.
  </div>
  </div><!-- text -->
  <div id="sidebar">
  </div><!-- sidebar -->
  <script type="text/javascript" src="../js/blog_sidebar.js"></script>
  </div> <!-- body -->
</body>
</html>