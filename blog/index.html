<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>Sucha's Blog - Welcome</title>
    <meta name="generator" content="MarkdownProjectCompositor.lua" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="Sucha" />
    <meta name="keywords" content="suchang, programming, GNU, Linux, Emacs, Lua" />
    <meta name="description" content="Sucha's blog" />
    <link rev="made" href="mailto:suchaaa@gmail.com" />
    <link rel="shortcut icon" href="../images/ico.png" />
    <link rel="stylesheet" type="text/css" href="../styles/blog.css" />
    <!--[if lte IE 6]><link rel="stylesheet" type="text/css" href="../styles/ie.css" /><![endif]-->
  </head>
  <body>
    <div id="body">
      <div id="text">
	<!-- Page published by cmark-gfm begins here --><h1>Sucha's Blog ~ Welcome</h1><div class="date">21年3月15日 周一 20:46</div>
<h2>西行漫记读后感</h2>
<p>也许是从某个微博用户上面读到了有关西行漫记的点点信息，于是就找来看了，读的是微信读书上面的版本，试用了几天无限卡才读完。</p>
<p>这本书名字实际是《红星照耀中国》，但我搜时用的就是西行漫记，到底是从哪里读来的标题忘记了，之前命名为西行漫记，是因为在解放前，国统区其实不能出版红色读物，所以命名为西行漫记是为了好低调传播。</p>
<p>在这之前，有在 B 站上看了沙盘推演里面李得胜的四渡赤水，徐海东等出神入化的战争艺术。</p>
<p>话题转回来，这本书是西方第一次了解到红色中国的窗口，当时斯诺也是费了不少劲才从白区去到红区，因为红区被完全封锁了，留有少许的时间窗口，刚好也应该是在西安事变之前的一小段窗口期，东北军不鸟常凯申，没有围剿红军，而是准备秘密合作，于是有了空隙，斯诺终于找了一个机会去了红色根据地，不过当时还有大财主的民团各地流窜，被碰到会没命，也是很危险的。</p>
<p>斯诺去之前是满腹孤疑，对根据地、红军的方方面面一堆的疑问，第一天就见到了周总理，被总理给安排了 90 天的行程，心里还觉得时间太长了，后面实际花了 120 天，走的时候还恋恋不舍。</p>
<p>里面篇幅其实挺多的，最精彩的，当然是访问李得胜的记录，以及对于红军如何得到广大农民支持的描述。</p>
<p>里面的不少论述在论持久战里面其实也有，当时就很客观，深入的讨论了中国人民抵抗日本的必然胜利，所需要的条件，什么是主要条件，什么是次要条件，什么是内部条件，什么是外部条件，为什么这些外部条件会成立，另外战争会分几个阶段（应该是论持久战里面的了，都混在一起说了吧），然后中国的优势和劣势，日本的优势和劣势，等等。</p>
<p>李得胜说这些话是很有资本的，毕竟国共内战已经 10 年了，经历了五次大围剿，还发展壮大了。</p>
<p>还讨论了具体会用的战略，“战略应该是一种在一条很长、流动的、不定的战线上 进行运动战的战略，快速进攻、快速退却，是一种大规模的运动战”，“我们的战略和战术应该注意避免在战争初期阶段进行大决战，而应该逐步打击敌军有生力量的拾起、斗志和军事效率”。</p>
<p>说到得到农民拥护，当时军阀割据，为了养兵，各地都横征暴敛，征税都预征了几十年，国民党代表的是大地主、大资本家、以及国外资本的势力，广大的农民们只能是越来越穷。</p>
<p>为何会拥护共产党呢，是因为土地革命，革了大地主的命，将地分给广大农民，少征税，因此各地都收到广大群众的欢迎，这个国民党是做不到的。这也是红军为何是初期很穷的原因，也是为什么如燎原之火的原因，真的因为各地都是军阀，广大农民活不下去了。</p>
<p>对比一下，李得胜在回答斯诺对印度的看法时，说”印度不经过土地革命，是永远不会实现独立的“。当然印度在 1947 年就独立了，不过应该是类似国民党上台一样吧，代表的是大地主、大资产阶级的利益，现在种性、各地利益分割就可以看到，显然生产力远未得到解放。</p>
<p>估计是年龄大了吧，现在都喜欢看这样的书了。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2021-03.html#p0">Permalink</a></div>

<div class="date">21年2月16日 周二 18:24</div>
<h2>Swift(3) - PageEventBus</h2>
<p>春节在家，继续思考了一下业务上的一些痛点，并做了整理，趁春节期间的空闲，搞了一个改善页面内通讯，限定 UI 及业务逻辑绑定关系的库 <a href="https://github.com/lalawue/PageEventBus">PageEventBus</a>。</p>
<p>先说一下之前在业务上觉得不爽的点：</p>
<ul>
<li>页面内非常多的输入组件、点击开关，以及可改变当前页面显示内容的可选项</li>
<li>这些点击开关、可选项的变化会导致页面展示内容的变化，以及输入组件的刷新，以及精度展示的配置</li>
<li>这些点击开关、可选项、显示内容、输入组件可能处于页面内各种不同层级的 UI 中，比如可以是 child view controller 等</li>
</ul>
<p>说一下之前的处理方法，使用 RxSwift，各种不管 UI 层级多深的 binder、controlProperty、controlEvent，都透过多层 UI，传递到业务 view controller 这一层来做绑定，带来的问题，有以下几个</p>
<ul>
<li>业务 view controller 急速膨胀</li>
<li>穿透用的 UI 层级，不得不写 controlEvent、binder，但实际上是其 subviews 进行处理</li>
<li>当业务变化时，每一层涉及到的 UI、业务 view controller 都要做出修改</li>
<li>UI 绑定了业务，复用很难</li>
</ul>
<p>基于上面的问题，我有了一些思考，希望有下面这样的东西</p>
<ul>
<li>UI 跟业务分离，业务逻辑能够操作 UI，UI 独立可复用</li>
<li>具体的业务可以分割到不同的业务单元处理，接收消息，可以将处理结果传递出来</li>
<li>当业务需求变化时，希望不会因为输入、输出参数的变化，而修改 UI</li>
</ul>
<p>就想着能否用上一个页面内的总线，将参数通过总线传递，这样可以对抗业务需求上导致的参数变化，比如 view model 可以接收总线消息，也可以发送消息，有了总线后，可以不需要关心 UI 层级了，也没有参数需要透传了。</p>
<p>另外，UI 的输入、输出抽象到业务逻辑 view model 的输入、输出，可以认为 view 持有了 view model，view model 持有 unowned view 的不可变引用；对于 view controller，也可以相应的持有 page model。这样，UI 总是可以复用的，而 view model，才处理实际业务，如果多个业务本身可以抽象到更高的层级，那么显然 view model 也是可以做到的。</p>
<p>还加上改进的一点，由于上面接收、发送事件的角色都在系统展示树上，可以利用 responder chain 链，在 view didMoveToWindow 或者 controller viewDidAppear 的时机，做事件总线的绑定，意味着总线本身都不需要传递，可以自动连接上。</p>
<p>上面的一些思考，加上春节空余时间的实践，就是上面说到的 <a href="https://github.com/lalawue/PageEventBus">PageEventBus</a>。</p>
<p>一些代码上的具体实践：</p>
<ul>
<li>基类是 BlockEventAgent&lt;E,R&gt;，泛型的两个参数，一个是输入类型，一个是输出类型，可以用 enum 分类限定</li>
<li>BlockEventAgent 拥有名字，当它们接收到消息，返回处理结果的时候，可以知道是谁返回的</li>
<li>BlockEventBus 很简单，添加 agent、以及给各个 agent 发送消息，搜集结果并返回给调用方</li>
<li>BlockViewModel&lt;V:UIView,E,R&gt; 泛型限定了具体操作的 view，创建的时候就需要输入 view 实例，其生命周期小于等于 view</li>
<li>BlockPageModel&lt;C:UIViewController,V:UIView,E,R&gt; 绑定了 view controller，可以选择生成 event bus，或者使用已有的</li>
<li>BlockView 和 BlockViewContnroller 都加入了在 didMoveToWindow 或 viewDidAppear 激活搜索已有 event bus 的逻辑</li>
</ul>
<p>话说这一整套限定的东西还是很多的，我准备使用 event bus 来传递 view model，view model 内部还是使用 RxSwift 来做业务绑定，view model 带 disposeBag，或者使用 view 的 disposeBag 也是可以的。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-02.html#p0">Permalink</a></div>

<div class="date">20年1月24日 周日 22:52</div>
<h2>Swift(2)</h2>
<p>又写了一个多月的 Swift，除了刚开始时的修修补补，慢慢扩展到页面框架部分，不过这个部分我还是不够熟悉，一部分在于我还是沿用项目之前的 ViewModel，另外一部分，很多业务细节还没能深入理解。</p>
<p>虽然这次的标题是 Swift(2)，实际内容大部分是 RxSwift 及 ViewController 的结合，以及一些 UI 层级的实践心得。</p>
<h3>页面框架</h3>
<p>先说一下我们的网络层，搭建了类似 Moya 的网络层框架，基本上是够用了，但相比之前用的 Model 网络层，这里浅浅的封装，就不会有单独的 model 管理器了。简洁是简洁了很多，但是数据层面转换和粘合就得在 ViewController 处理，带来了 ViewController 的膨胀。比如因为用了 RxSwift，同一份数据，有时需要多次 transform，subscribe，这些可都在 ViewController 里面。</p>
<p>我曾经想过这些代码放在 ViewModel 里面会不会好一些，但我上次也许也有提到，这里的 ViewModel，更像是一个 Driver.System 的状态机，初始状态是 initial，之后是 Signal -&gt; Driver 的状态切换，通过一个 reduce 函数检查 ViewModel 绑定的 struct 结构来判断到底应该 loading、setResult 还是其他，如果弄懂了这个，页面的状态处理就很清晰了。</p>
<p>只是这个 ViewModel 只负责将 app 外的数据，transform 为页面状态数据，不涉及到 UI element 数据的 transform，这是跟之前 ViewModel 的区别。ViewModel 带回来的页面状态数据，最终会在 ViewController 中 transform 并 binding、drive UI element，这个过程有时需要做很多的粘合工作，流程也会相当复杂。</p>
<p>另外，UI 层级方面，已有较为复杂的页面，通常 UI View 就好几层，一层一层的 UIStackView 包裹里面的自定义子 view，将需要传递的数据链路，通过 binder 传递出来，即便是 View，都跟 RxSwift 框架直接绑定了。</p>
<p>说一下对这个的理解，我觉得是没必要，因为这个 binder 或者 driver，其实都只算是单向的数据传递，传递出来的时候用就好，传递进去的时候，感觉其实没那么必要的了。</p>
<p>以上提到的，觉得最复杂的还是 ViewModel 及其 Driver.System，基本上抄了几遍，这段时间除了 K 线 ViewController 没有修改过，其他页面多少接触了一点。</p>
<p>目前的页面框架工作得还可以，通用性也还行，只是觉得业务复杂度还是太靠近 ViewController 了。而且当前的框架，ViewController 绑定 TableView 被封装得很厚重，仅支持单种 cell 的 TableView，不知道当时这个模版构建的时候是怎么想的。</p>
<p>还有 TableView 的 DataSource，依赖了 RxDataSource，在 TableView 上，其实不支持 HeaderView 的数据流绑定，还得用回系统提供的 delegate 方式，不伦不类的，还不如全部都用系统的方式呢，因为这个模版框架，将 createCell 的部分，dataSOurce 的数据创建部分，放在了 TableViewCell 里面，这个我是非常不认同的。</p>
<p>我总觉得 Cell 有复用的可能，两者结合不应该那么紧密，即便有 protocol 作为粘合，有时候还是觉得抽象过了，没必要。</p>
<ul>
<li>业务强依赖 RxSwift，不够纯粹，不适合封装带给非 RxSwift 的第三方使用了</li>
<li>页面状态处理优秀，但带来未解决的问题，是业务复杂度又堆积到了 ViewController，除了 VC 臃肿之外，还有就是其实没有业务子 View 的划分，因为其输入输出都在 ViewController，边界不明确</li>
<li>TableView 的页面模版虽然能处理当前业务的问题，但设计之初未考虑到各种其他情况，不够灵活</li>
</ul>
<p>这段时间还将 Carthage 的库切换到了静态库上，模拟器运行节省了不少时间，但这个改进在真机上几乎觉察不出来。</p>
<p>做了这部分的心得是，我们依赖的第三方库实在是太多了，这也造成了我们启动慢，因为打包好的 App 就有 150M+。比如我们的数据库，为何要用 Realm 呢，是因为 ORM 方便吗，还是因为它更快，总觉得还不如用系统提供的 SQLite3 好了，或者浅浅地封装一层一层，比如 GRDB 就好。</p>
<p>因为这个库太大了，打包的时候都可以看到打的慢。</p>
<h3>UI 层级</h3>
<p>学习使用 UIStackView，其实这个我在几年前就有做了一个基于 frame 计算的 StackView 框架，可惜是公司财产，不能开源出来（显然我也没有源码）。</p>
<p>UIStackView 使用有些前提，一方面需要 addArrangedView 添加进来，但是如果只是删除 ArrangedView，其实还在 subviews 里面。</p>
<p>另一方面，每个 view 需要有自己的 size，以及 hugging、compress 优先级，要不感觉最后计算宽度大小的时候，总是不准确。</p>
<p>还有学会了在 tableview 的 header view 上面放置复杂的 UI 层级，这个 tableView 的 header view，不支持 AutoLayout，只能是指定 frame 高度。</p>
<p>但是呢，又能通过将这个 view systemLayoutSizeFittingSize 拿到高度，设置给 frame 来确定这个 tableview header view 的高度。</p>
<p>还有 table view 的 cell 是可以不指定高度的，通过 AutoLayout 计算出来，但是呢，collection view 不可以。</p>
<p>这段时间因为对这些 UI 规则不熟悉，浪费了很多时间，有时想着，还不如我来设置 frame 呢，工作早就做完了。</p>
<p>另外，复杂一点的首页等等 ViewController，各种 NSLayout warning，见怪不怪，设置符合 AutoLayout 的规则，太难了。</p>
<p>哦，对了，我们有两套 layout 的库，一个是 SnapKit，一个是 TinyConstraint，常常是混用的状态，真的有点混乱。</p>
<p>--</p>
<p>大概先这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-01.html#p0">Permalink</a></div>

<div class="date">20年12月13日 周四 22:38</div>
<h2>Swift(1)</h2>
<p>ObjC 我挺熟悉的，但切换到 Swift 的路并不顺利，虽然我之前写过一个结合 Swift + ObjC 运行时的换肤库 <a href="https://github.com/lalawue/LWTheme">LWTheme</a>，现在看来，确实是相当 ObjC 呀。</p>
<p>写了一点点商业 Swift 代码后，我现在还不能说我熟悉 Swift 了，Swift 内容太多了，特别是 Enum 以及带泛型的 Protocol，抽象能力太强了。</p>
<p>先开始吧。</p>
<h3>函数式书写静态类型推断</h3>
<p>纯 Swift 相比 ObjC，类型推断能力大大加强，算是一个静态语言，没有什么动态运行时，但 Target-Action 部分，在 Switch 里面，其实还是依赖 ObjC 运行时来跑的。</p>
<p>带 Optional 的静态推断，最大的好处，是类型安全，带 nil 的指针不会到处飞了。一眼开过去，Swift 的语法很像脚本语言，实际使用起来，也很函数式，很多时候，确实是用更少的代码粘合了更多的功能，带来的问题是能量压缩是想当大的。</p>
<p>反面的例子如下：</p>
<pre lang="source"><code>let stringArray = [&quot;a&quot;, &quot;bb&quot;, &quot;cc&quot;]
let countsArray = stringArray.filter { $0.count &gt;= 2 }.map { $0.count }
print(countsArray)
</code></pre>
<p>输出是 [2,2]</p>
<p>假若 stringArray 带的是其他的类型，而在 countsArray 里面的 filter、map 操作有很多，那里面一长串的 $0 看的真的让人头大，因为实际的代码可不会像上面这样只有 2 行，也不会仅仅只有一种 transform，而是各种转换带下来，表达密度真的太大了。</p>
<h3>闭包及简写</h3>
<p>闭包相比 ObjC 容易写多了，但也有一些变种，比如上面 filter、map 的参数就是闭包，闭包只有一行的时候是可以省略 return 的，还有尾随闭包，比如上面的 filter 及 map，下面这个也是尾随闭包</p>
<pre lang="source"><code>let seq = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;].sorted { $0 &gt; $1 }
print(seq)
</code></pre>
<p>输出是 [&quot;C&quot;, &quot;B&quot;, &quot;A&quot;]</p>
<p>不得不说 Swift 的语法有点过于自由，这些隐含的缺省用法，看代码的时候得留意了。</p>
<h3>Enum 的相关值</h3>
<p>Swift 的 Enum 语法不仅仅是只有枚举，以及 raw value，还可以带相关值，提升为了一个带标记的容器，使得即便作为一种输入，其输入内容其实也是千变万化的，只是标记了一种路径输入而已，输入内容是带进来的，比如</p>
<pre lang="source"><code>enum Goods {
    case name(String)
    case price(Int,Int) // 任性的将小数做为单独的 Int 带入
}
</code></pre>
<p>除了上面，常见的例子还有定义网络请求，将部分请求参数做为相关值带进来。</p>
<h3>结构体</h3>
<p>struct 相比 class，不能被继承，以及都是值传递而不是引用传递，这点让人不是那么满意，虽然写代码的时候往往不会注意到这点。</p>
<p>因为现实世界中的结构体其实可以很大的，有时候不是刚开始设计的问题，是后续的需求催大的。</p>
<h3>泛型</h3>
<p>有了严格的类型推导，泛型到处都可以存在，这种抽象容器能力，是 ObjC 所达不到的了。</p>
<h3>protocol 及 extension</h3>
<p>Swift 的 protocol 结合泛型，然后 extension 使用 protocol 将 class 能力大大扩大了，感觉就像是一种带入的计算属性一样，强。</p>
<p>现实中的 protocol 加上泛型，结合类实现，将类抽象为一个巨大的逻辑容器，代码真是让人看得头大，但另外一方面，不得不说如果是类似数据构建的页面，数据逻辑的抽象层让人放心了。</p>
<p>当然 UI 操作逻辑的抽象层也是可以做的。</p>
<h3>访问控制</h3>
<p>相比 ObjC 运行时的无所不能，Swift 带来了严格的访问控制，open、public、internal、fileprivate、private 应该有这五种吧，让 ObjC 转行过来的同学头都大了。</p>
<p>--</p>
<p>潦草的先这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2020-12.html#p0">Permalink</a></div>

<div class="date">20年11月9日 周一 16:02</div>
<h2>JavaScript(1)</h2>
<p>学习了一下 javascript，使用的是 <a href="https://wangdoc.com/javascript/index.html">JavaScript 教程</a>，基础的 ES5，包含的内容可太丰富了。</p>
<p>跟其他语言的差别，主要在语法、面向对象，基础库和运行环境这几个部分。</p>
<h3>语法</h3>
<p>语法部分，'==' 可真够让人头疼的，为了比较会自动转换类型，所以教程建议直接使用 ‘===’ 进行严格比较。</p>
<p>相对高级的语言，都有 &lt;&lt; 和 &gt;&gt;，甚至 &gt;&gt;&gt; 操作符，可惜了，Lua 5.1 比如 LuaJIT 并没有这么好用的操作符，只能通过 bit 库来使用，或者塞给 C 代码处理吧。</p>
<p>JS 里面的 null 和 undefined 也得注意一下，它们几乎是一样的，除了 null 在 Number(null) 时为 0，而 Number(undefined) 为 NaN。</p>
<h3>面向对象</h3>
<p>这里一开始让我挺头疼的，比如原型对象及继承关系。</p>
<p>对比 C++/Java 的面向对象实现都隐藏在语言核心运行时里面，通过语法‘类’来实现继承，在类里面写构造函数，描述继承关系。且 C++ 因为是零成本抽象，极端强调运行时性能，继承、面向对象的逻辑在编译期几乎都解决了，只留下了动态派发给运行时处理。Java 有反射，任何时候都能拿到其继承关系，其所有的类都继承自 Object。两者作为静态语言，在运行时无法动态修改继承关系。</p>
<p>JS 虽然跟 Java 一样所有类都继承自 Object，但其继承的语言特性，是通过原型对象来实现的，运行时可以访问。原型对象就是类的 prototype 属性，构造函数则是 prototype.constructor，因为有 new 关键字的存在，定义一个新类，只需要定义构造函数就好了，比如</p>
<pre lang="source"><code>function Car(color) {
    this.color = color;
    console.log(&quot;color:&quot; + color);
}

var car = new Car(&quot;white&quot;);
</code></pre>
<p>会输出 'color:white&quot;。如果定义 Bus 继承 Car 是这么实现的：</p>
<pre lang="source"><code>function Bus(color) {
    Car.call(this, color);
}
Bus.prototype = Object.create(Car.prototype)
Bus.prototype.constructor = Bus

var bus = new Bus(&quot;red&quot;)
</code></pre>
<p>将输出 'color:red'，如果需要在运行时修改类的继承关系，propotype 和 prototype.constructor 必须同时修改。</p>
<p>感觉原型对象这个词，在继承关系上，跟 Objective-C 的类对象有一点像，不过实际表现及使用，千差万别。</p>
<p>对比 Lua 实现面向对象，感觉还是有一点像的，不过 Lua 里面实现面向对象，继承关系，需要了解的可太多了，需要了解 Lua 的元表（metatable）才好。</p>
<h3>基础库和运行环境</h3>
<p>作为一个动态脚本语言，JS 的基础库和运行环境挺丰富的，作为 Web 端统治性的语言，运行环境包含对 HTML DOM 的操作，以及浏览器环境，这两个部分我还没怎么看呢。</p>
<p>作为后端语言，基于 Node.js 事件驱动、非阻塞式 I/O 模型，极大降低了后端开发的难度，不过 Node 下的运行环境，我还没怎么接触。</p>
<p>虽然 JS 是单线程的 VM，但是 HTML 5 及 Node 都实践了其多线程交互的方式，也有了不同领域下的解决方案，其成熟程度，丰富程度，对比 Lua 可要好太多了。</p>
<p>引擎部分，标准桌面、后端用的是 Chrome V8，嵌入式应该用的是其他方案。现在已经有了前后兼容的 ES5、ES6 标准，貌似 ES7 也快要出来了。</p>
<p>--</p>
<p>总的来说，JS 是一门比较完善，还在不断渐进式发展，且考虑兼容性的编程语言，慢慢的将变成桌面应用编程语言，部分后端编程语言，可不再是脚本语言了。</p>
<p>相比 Go，JS 是动态类型，也不是静态编译的；相比 Lua，语言成熟度，库的丰富程度，应用范围都好好很多，没有 Lua 目的是宿主语言的累赘，虽然 Lua 还有速度上的优势。</p>
<p>而且，学会 JS 的好处可是，前端通吃，后端独立。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2020-11.html#p2">Permalink</a></div>

<div class="date">20年11月5日 周四 09:49</div>
<h2>go_bitcask</h2>
<p>学习了 Go 后要使用，实践的第一个程序是 <a href="https://github.com/lalawue/go_bitcask">go_bitcask</a>。其逻辑大部分源于 <a href="https://github.com/lalawue/ffi_bitcask.lua">ffi_bitcask.lua</a>。</p>
<p>但在 Go 这个版本中，因为一直开关读写文件效率比较低，所以做了一层抽象优化，将文件的读写抽象到了 DataFile 里面，其中，读的部分使用了 mmap，写的时候只保留一个活跃文件，一直追加写，也兼顾当前活跃文件的读，待到关闭数据库的时候才做 Sync()，并关闭文件。</p>
<p>在我的 16 年 MacBook Pro 版本 10.15.7 中，Go 1.13.4 读写文件极慢，LuaJIT FFI 版本用了不到 0.2 秒完成的测试，在 Go 这边需要 2 秒，太夸张了。</p>
<p>试了一下在云端 Linux 上面，效果好了很多，大概需要 0.2 秒，但 LuaJIT FFI 版本只需要 0.02 秒</p>
<p>LuaJIT FFI 版本的 bitcask</p>
<pre lang="source"><code>$ time luajit test/test_bitcask.lua
PASS Bucket
PASS Set/Get
PASS Delete
PASS GC

real    0m0.021s
user    0m0.011s
sys     0m0.008s
</code></pre>
<p>Go 版本我编译后才测试的</p>
<pre lang="source"><code>$ time ./test
using database: {Path:/tmp/go_bitcask BucketName:0 DataFileSize:512}
Pass Bucket
PASS Set/Get
PASS Delete
PASS GC

real    0m0.234s
user    0m0.004s
sys     0m0.030s
</code></pre>
<p>也许 Go 启动准备需要不少时间吧，或者是我实现的问题。</p>
<p>在 Go 版本中，我同样是使用了 struct map 到内存的方式来表示一条 record，然后一次性读取 key 及 value，再 slice 切割为 key 和 value。</p>
<p>映射的代码如下，感觉也没什么呀</p>
<pre lang="source"><code>// map recordinfo to bytes
func recordInfoToBytes(ri *recordInfo) []byte {
        var x reflect.SliceHeader
        x.Len = int(recordSize)
        x.Cap = int(recordSize)
        x.Data = uintptr(unsafe.Pointer(ri))
        retBytes := *(*[]byte)(unsafe.Pointer(&amp;ri))
        return retBytes[:recordSize]
}

// map byte to recordinfo
func bytesToRecordInfo(b []byte) *recordInfo {
        return (*recordInfo)(unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(&amp;b)).Data))
}
</code></pre>
<p>也许完全运行起来以后，Go 的速度才会又继续上去吧，我 pprof 的结果，是 system call 占用时间最多，其中 Set 是占用很多的，其次是 GC，但是 GC 不常用，这个倒没什么关系。</p>
<p>Set 占用多，感觉说不过去呀，因为就检测如果有重复 key，做了 remove，然后再 set 新的 key/value，两次 system call write 函数。</p>
<p>也许 Go 版本真的应该做完整一些，将写的操作单独一个 goroutine，并且做 LSM 操作，将读写都 encode/decode 起来，再做一层抽象才好吧，但是目前这个算是简单版本，不打算再做这一层了。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2020-11.html#p1">Permalink</a></div>

<div class="date">20年11月4日 周三 10:32</div>
<h2>Go(1)</h2>
<p>又开始学习 Go，之前其实断断续续看过一些，因为没有实践过，也陆续淡忘了不少，现在重新拾起，教程用的是 <a href="https://github.com/Go-zh/tour">Go 语言官方教程中文版</a>以及另外一本（彻底贯彻学完就扔的习惯现在找不到网址了），后面因为反复查询标准库，用了很多 <a href="https://studygolang.com/pkgdoc">Golang 标准库文档</a>。</p>
<p>Go 是一门命令式的语言，入门曲线比较低，比如非面向对象，简单的控制流、少了继承、枚举等等，变量声明也简单明了；但是要掌握我觉得不算简单，比如 goroutine 以及 CSP 数据交换的并发模型，slice、反射等，因此学习起来有一个曲线。</p>
<p>Go 有不少必知必会的语言规定，比如变量名首字母大写才会在包里面导出，变量需要驼峰命名，带间隔的下划线是不被推荐的（VSCode 里面的 golints 有对我多次提示啦）。相比 C/C++、Java、Lua 等，我觉得变量声明、defer、slice、接口、并发模型、包管理系统，是 Go 的特色，可以拣出来说一说。</p>
<h3>变量声明</h3>
<p>这个知识点很简单了，可以不用指明变量类型，让系统推断，比如</p>
<pre lang="source"><code>a := 10
</code></pre>
<p>或者指明类型</p>
<pre lang="source"><code>var a uint32 = 10
</code></pre>
<p>上面的两种是有区别的，第一种 Go 默认是 int 类型，下面指定了 uint32 类型，Go 是强类型语言，变量的后续使用必须对齐类型，否则编译报错。当然可以这样写 a := uint32(10)，成功用第一种方式声明了 uint32 类型。类型转换还有下面这样的</p>
<pre lang="source"><code>var b interface{} = 10
var c interface{} = &quot;hello&quot;
var d string = c.(string)
fmt.Println(b, c, d)
</code></pre>
<p>可以看到，虽然 Go 没有 C/C++ 的 void*，但可以用万能的接口 interface{} 弥补，interface{} 还可以在运行期用来做类型推断，这里不细说了。</p>
<p>Go 里面方便的地方，if 控制块一开始就可以定义新的变量在控制块内使用，比如下面判断文件是否打开成功的例子：</p>
<pre lang="source"><code>if fp, err := os.Open(&quot;/path/to/file&quot;); err != nil {
    defer fp.Close()
    // ...
} else {
    return err
}
</code></pre>
<p>上面的 fp、err 只能在 if 及 else 块内使用，出了 if、else 的控制范围，编译会报错。</p>
<p>以上，方便的变量定义，算是 go 的特色了，其方便程度，跟 Lua 有点像，但是 Lua 默认是全局可见的，Go 有控制块的限定，包内控制块之外必须首字母大写才能导出。对于大型系统，我觉得 Go 的定义更稳妥一些。</p>
<h3>defer</h3>
<p>上面的例子已经提前用了 defer，比如在文件打开成功后，defer 了一个关闭函数，当 if 语句所在函数返回后，defer 按照先进后出的原则退栈运行。</p>
<p>defer 运行的只能是函数，所以如果是一些变量需要离开函数后保存，可以下面这样</p>
<pre lang="source"><code>stepRecorder = &quot;enter function&quot;
defer func(){
    stepRecorder = &quot;leave function&quot;
}()
// ...
</code></pre>
<p>defer 写得太爽了之后，遇到了习惯的反面，比如在 for 循环里面打开了文件，希望下个循环关闭，就老想着能够有这样一个关键字，在当前循环结束前运行这个关键字后面带的函数，因为在复杂的 for 里面，有 return，还有 continue，还有正常的流程。</p>
<p>然而 Go 没有这样的关键字，所以很遗憾的老老实实按老路子写代码了。</p>
<h3>slice</h3>
<p>Go 里面 array 跟 slice 有紧密的联系，我总感觉 array 是 slice 的特例，是一个预定义的 slice，举个例子：</p>
<pre lang="source"><code>a := []int{1, 2, 3, 4}
b := a[:2]
fmt.Println(a, b)
</code></pre>
<p>打印出来的是下面这样的</p>
<pre lang="source"><code>[1 2 3 4] [1 2]
</code></pre>
<p>可以看到其实两者底层是一致的，只不过 array 固定了 slice 的 len 和 cap，slice 的切割是左闭右开的区间 [)，类似 for 定义的 for i := 0; i &lt; 5; i++ 的一个语言习惯吧。</p>
<p>slice 可以使用 append 扩容，比如</p>
<pre lang="source"><code>b = append(a, 5)
</code></pre>
<p>结果是输出</p>
<pre lang="source"><code>[1 2 3 4 5]
</code></pre>
<p>slice 使用 make([]int, 5) 等方式定义，虽然用着像数组，但实际上可变长度的设计跟 C++ 里面的 vector 有点像了，由于 Go 没有 C++ STL 的 vector，slice 就是这样大量使用了。</p>
<p>不过我总觉得，虽然底层的抽象是这样，但是用着确实不方便，使用者得很熟悉底层的抽象、分割才行。</p>
<h3>接口</h3>
<p>Go 没有继承，没有 Java 这样 Object 的基类，也就没有面向对象的基础。其语言设计者认为面向对象不是必要的，特别是深层级的继承，过于复杂了。其推荐通过接口抽象，所有实现了接口定义函数的 struct 类型，认为具有接口的功能，是接口抽象的代表。在实现上 struct 没有特别的关键字来声明实现了某些接口，编译期、运行时核心是知道的，提前匹配了。</p>
<p>比如我们定义一个接口，并写某个 struct 实现接口</p>
<pre lang="source"><code>type Dog interface {
    Name() string
}

type BullDog struct {}
func (dog *BullDog) Name() string {
    return &quot;BullDog&quot;
}

var dog Dog = nil
dog = &amp;BullDog{}
fmt.Println(&quot;dog is&quot;, dog.Name())
</code></pre>
<p>以上，斗牛犬 BullDog 实现了 Dog 的 Name() 接口，没有声明实现的关键字，只需要实际实现了这个接口，就可以编译运行通过。</p>
<p>通过上面的定义，对比 Java 的接口、抽象基类定义，可以想像，由于 Go 没有继承，以及 interface 的默认实现或者说抽象基类的东西，也没有函数重载，如果在 Go 里面定义了复杂的接口，或者某些特性通过接口暴露但只有很少量的实现需要特别处理，都是一件头疼的事情吧。</p>
<p>不过相反的，在稍微大型一点的代码里，应该可以新定义调整一个接口来区分不同的类型实现吧。</p>
<h3>并发模型</h3>
<p>Go 的并发模型是 goroutine，定义了函数后，通过命令字 go 来驱动，其通讯模式，用的是 CSP，通过管道（channel）通讯，而不鼓励通过共享变量通讯。</p>
<p>C 抽象了体系的基本寄存器，C++ 是个牛刀，多模式的语言，但在早期的语言规范里面，没有多线程的定义，我查了一下，直到 C++11 才有语言提供的多线程，Java 的多线程语言内置支持，但是 C/C++/Java 的多线程实现，可以看成都是 pthread 的封装，一个语言线程，对应操作系统的一个线程。</p>
<p>但在 Go 里面不是这样的，Go 的线程独立于操作系统的线程，是协程，但调度是 Go 核心在用户空间实现的，虽然用起来跟线程类似。goroutine 的通讯、锁，官方的例子都是建议通过 channel 传递数据以及控制，但实际上不是什么都适合在 channel 中传递，有时候传递行为的控制反而是复杂的，所以也是有锁的，得合理区分场景使用，且这个时候的锁也是得考虑死锁的。</p>
<p>由于没有很深入的使用，这里就不展开了（没实料了）。</p>
<p>对比一下 Lua 的协程，Lua 是单线程模型，因为 Lua 语言本身的设计就是一个宿主语言，最开始的设计是靠着 C，而 C 的语言核心没有定义线程的，这也导致了 Lua 协程的设计没有考虑多线程。网上 Lua 多线程的模式，其实就是 C 多线程的模式，一个 C pthread 线程，带一个 Lua VM，通过 CSP 或者共享内存通讯。</p>
<p>而 Go 直接抽象了协程、CSP 这套协程、多线程通讯机制。</p>
<h3>包管理系统</h3>
<p>Go 的包管理系统我有看过浅显的资料，区分不同发展阶段，有使用 vendor 目录带支持包，或者新版本 go mod 的阶段共享支持包。</p>
<p>Go 使用关键字 package 定义包，包里面首字母大写导出函数或者变量，这是语言的强制约定，减少了关键字，另外 main 函数是打包编译为二进制后的运行入口。</p>
<p>C/C++ 是没有明确包管理的，只有系统层级的二进制库，以及编译、链接顺序。理好 include，然后依赖不同的 build tool 来构建，比如大名鼎鼎的 make，或者 Nijia，一般不会生成静态链接的二进制，当然也可以生成，只是真的很少见，由于可以控制编译期的任何一个阶段输出，在嵌入式应用可好了，输出动态链接，还可以各种裁剪，但相反就是要求高了不少，得自己学会搞定编译运行期的所有问题。</p>
<p>Java 语言的定义也是不带包管理工具的，但工程实践是有 mavel 或者 gradle，我不熟悉，就不展开了。</p>
<p>Lua 也没有包管理，不过默认的操作系统文件夹，都可以是一个包层级，然后命令行可以指定在哪里寻找包，以及动态库。</p>
<p>话说 Rust 也有包管理，但我没有深入具体跟仓库是怎么结合的。</p>
<p>我只用过 go mod 的包管理，go mod 命令行初始化后，感觉后面就很简单了。再说 IDE 也是强，VSCode 配置好后，任何不需要的包，都无法导入，而实际用了标准库的包，IDE 都自动帮忙导入到 import 里面。</p>
<p>感觉强在 github 等依赖外部仓库的包，go mod 看到有用到，运行 tidy 命令后，可以帮忙直接下载，这里并不依赖中央仓库的，算是一个特色，毕竟类似 CocoaPod 也是有中央仓库的，或者起码得指定私有仓库的地址才行。</p>
<p>编译成静态链接的的好处，是可以无视系统版本了，对于大型的程序，增大的这点空间不算什么，毕竟对比大量异构部署来说，极大减轻了部署的困难，俗称统一交付。估计谷歌内部对于 C/C++ 可以输出静态链接的版本，早就这么做了，估计不这么做的话，那么多个二进制输出版本，debug 也有困难吧。</p>
<p>从包管理，可以看到交付的逻辑，当然也注定了 Go 不会应用到嵌入式里面。除非能出一个非静态链接的版本，但是 Go 的核心运行时，能够单独出供动态链接的二进制版本吗，感觉往这个方向的估计都没考虑了。</p>
<p>有脚手架的语言，Rust、Go 是很方便的，有统一的脚手架，也规范了交付的正统逻辑。</p>
<p>--</p>
<p>用 Go 写了一点小东西，所以有了上面的一些思考，可惜是还没有用上 goroutine，那就先输出这么多吧。</p>
<p>最后说一下内存占用，C/C++ &lt;- Lua &lt;- Go &lt;- Java，Lua 不是正统的非宿主语言，这里有加入 VM 对比的考虑，一般的评测，都是认为 Go 是要比 Java 快的，再说 JVM 基本占用内存就很大了，如果不是大型程序，用 JVM 的成本会比较高。</p>
<p>但是 Java 多年来的基础建设都很好，不管是 JVM 还是 IDE，我用过最好的 IDE 就是 Java 的，太省心了。但是另一方面，Java 的交付、部署应该是没有 Go 的简单，至少也是有 JVM 版本的，而 Go 真的就是统一交付了。</p>
<p>Go 席卷了互联网，Docker 及云的基础建设就是明证，Java 瓜分了剩下的很大一块，接着是 Python 的简易运维，C++ 是核心中的核心，不晓得这个分布是不是当前占有率的反映。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2020-11.html#p0">Permalink</a></div>

<div class="date">20年10月26日 周一 22:48</div>
<h2>《在故宫寻找苏东坡》</h2>
<p>一直很喜欢苏东坡的词，不记得在哪里看到了推荐，就买了这本书。</p>
<p>这本书随着苏东坡的一生展开，考取功名、入仕、被贬，然后其诗词的变化，心境的变化，所写词在当时心境的解读等等。</p>
<p>考取功名、入仕在前面几章，不表。</p>
<p>被贬是因为文字狱，经历了生死，但苏东坡并未因此颓废不堪，像陶渊明一样淡泊修仙，远离尘世，相反他一直在入世，只是不再朝中爭功名了（精神小伙爭儒家正统）。</p>
<p>被贬到黄州后，俸禄不够养活全家，不得不把自己当成农民，在县城东边买了一块地自给自足，并自称东坡居士。种植、收成、酿酒，看到黄州人民不爱吃猪肉，猪肉很便宜，又自创了东坡肉。这一切充满了泥土间的汗水、快乐，满是人世的酸甜，虽然消瘦了许多，但却是脚踏实地的。</p>
<p>随着王安石新政停摆（老皇帝驾崩），新皇帝又将苏东坡等老臣请上了朝，但是快乐很短暂，很快又因为写诗词的影响被贬。</p>
<p>即便如此，短暂的就职，也给杭州留下了疏通后的西湖，淤泥堆成了白堤。然后是一路向南的贬职，最远到了海南岛。当时海南岛都还是原住民，以当时的条件，过了海就当成是半个死囚了，当时那边连书都没有，这是他最痛苦的地方。</p>
<p>书籍里面对于苏东坡诗词画的介绍，结合当时环境、心境的分析太细腻了，我表达不出来，对比在其时代之前相同的主题，认为其自创了一派，在表达，艺术以及美的结合上，大大拓展了延伸的范围。</p>
<p>最悲哀的是，作者认为诗、词的顶峰在千年以前，自从苏东坡之后，就没有诗、词的达人了，至少没有那种高度的。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2020-10.html#p2">Permalink</a></div>

<div class="date">20年10月21日 周三 20:51</div>
<h2>ffi_gccload 在 Lua 中动态加载 C Source</h2>
<p>不晓得从哪里搜到了这个库 <a href="https://github.com/javierguerragiraldez/lua-tcc">lua-tcc</a>，可以在 Lua 运行期间，通过 one pass 的 TCC 动态加载 C 代码，让 Lua 的控制可以更深入底层，甚至可以在 Lua 中进行 C 的编程。</p>
<p>可惜这个项目距离久远，TCC 在 MacOS 下面编译也成问题，意味着通用性欠佳，挺可惜的。不过有了这个想法后，想着不通过 TCC，用 GCC、Clang 其实也可以的嘛，于是就有了 <a href="https://github.com/lalawue/ffi_gccload">ffi_gccload</a>。</p>
<p>流程变成了这样，将 C Source String 导入到一个源文件里面，通过 GCC 编译得到动态库，使用 ffi.load() 加载进来，并通过 ffi.cdef 声明接口，就可以使用了。</p>
<p>其实就是将 C 的编译、链接过程给固定了就好，如下的代码：</p>
<pre lang="source"><code>local config = require(&quot;ffi_gccload&quot;).new()

-- like ffi.cdef
config:addSourceDef([[
    int print_name(void);
    int add_num(int a, int b); 
]])
local p = config:loadSourceString([[&lt;a id=&quot;include&quot;&gt;&lt;/a&gt;
 &lt;stdio.h&gt;
int print_name(void) {
    printf(&quot;Hello, world\n&quot;);
    return 0;
}
int add_num(int a, int b) {
    return a * 2 + b;
}
]])
if p then
    p.print_name()
    local a, b = ...
    a, b = a and tonumber(a) or 0, b and tonumber(b) or 0
    print(&quot;result&quot;, p.add_num(a, b))
else
    print(&quot;failed to load&quot;)
end
</code></pre>
<p>生成一个动态编译配置，会输出</p>
<pre lang="source"><code>$ lua test.lua 2 3
Hello, world
result  7
</code></pre>
<p>其实是将编译产生的中间 .so 放在临时目录，加载后其实就可以删除掉这个 so 了，这在 MacOS 以及 Linux 应该都是可以的。</p>
<p>上面生成的动态编译配置，其实可以加入 include、libary 的 path 以及 lib name，已经越来越像一个 build 系统了，其实就是类似的。</p>
<p>有了上面这套，虽然相比 TCC 速度慢一点（毕竟 TCC 是 one pass 就出成果的），但是胜在兼容性号，修改一下后，估计 Windows 下面也是能跑的。</p>
<p>往后可以在服务端拿到 C 代码，捣鼓以下就能用到客户端上面了，或者一些少量使用 C 操作更方面的逻辑，结合放在 Lua 中作为源代码发布出去，使用的时候，先编译加载动态库，也是一个方案。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2020-10.html#p1">Permalink</a></div>

<div class="date">20年10月11日 周二 02:12</div>
<h2>DNS service 重构</h2>
<p>将 rpc_framework 中 <a href="https://github.com/lalawue/rpc_framework/tree/master/apps/service_dns">service_dns</a> 网络层的控制从 C 层移到了 Lua 层，C 层只负责 UDP 包的数据拼接、解包，将代码统一到了 <a href="https://github.com/lalawue/m_dnsutils">m_dnsutils</a> 里。</p>
<p>在减少了大量 C 跟 Lua 的交互后，两者算是各自做了自己擅长的方面，自测后的效果也不错。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2020-10.html#p0">Permalink</a></div>

<div class="date">20年9月29日 周一 18:25</div>
<h2>Rust(1)</h2>
<p>开始学习 Rust，从 <a href="https://github.com/lalawue/rustlings">rustlings</a> 入手，可以看中文版的 <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a>。看了两天书，边看边写习题，完全当成一门新语言来学，内容太厚重了，而且对于我自己已有的经验来说，跟我以往了解的语言，大不一样。</p>
<p>其实 Rust 无需垃圾回收的<a href="https://kaisery.github.io/trpl-zh-cn/ch04-00-understanding-ownership.html">所有权</a>（borrow）部分，为了防止多线程竞态条件的部分，有 C/C++/Java 多线程经验的话，是很好理解的。Rust 虽然也有指针，以我的理解，因为编译器可以确切知道具体引用情况，是不需要多写 *p 这样的了。</p>
<p>深入骨髓的不同，从编译器、语言设计角度来说，是模式匹配、None、trait、宏，字符串、迭代器。</p>
<h3>模式匹配</h3>
<p>模式匹配不仅仅只是 match 关键字，及其控制流，从 let 到 if let 都有模式匹配的影子，如下</p>
<pre lang="source"><code>let tup = (500, 6.4, 1);
let (x, y, z) = tup;
</code></pre>
<p>上面就是元组的模式匹配，如果数量或类型对应不上，编译期就抛错误。而 if let 是为了简写 match 出现的。因为 Rust 自己的错误处理机制，其实大量用了 if let 或者 match，所以模式匹配一定会遇到的。</p>
<p>Rust 这里还深入提到了一点，有些模式匹配必须成功，程序才能编译通过，比如上面的例子，下面 Some(T) 在其实也是模式匹配，是可以接受匹配失败的。</p>
<h3>None</h3>
<p>跟很多语言不同，Rust 的 None 不算是一个值，而是一种状态，是我的感觉。下面两个是语言固定了的，一定会遇到</p>
<pre lang="source"><code>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

pub enum Option&lt;T&gt; {
    /// No value
    None,
    /// Some value `T`
    Some(T),
}
</code></pre>
<p>Result 用于表明结果是否正确，正确的使用 Ok(T) 返回，错误的用 Err(E) 返回，具体的值需要解包才能使用。Option 表示要么有值，要么没有值，Option::None 没有别的作用，就只是表明没有值而已，如果是 Some(T) 返回的，也是需要解包才能用具体的值。</p>
<p>Lua 的 nil 是 false 含义，还能塞入 table 表示 array 终结，ObjC 的 nil 也是 false 的含义，还能初始化指针，C 里面的 NULL 同理，Java 里面的 null 也是经常用来比较的，还容易引发 NullPointerException，反正是一个大量使用的合理值，新世代的 C++ 我不了解了，但 Rust 不一样，None 就是没有值，是一个枚举定义，我们经常使用且想见到的是 Some(T) 包裹的值。</p>
<h3>trait</h3>
<p>Rust 没有继承，跟 C++/Java 不同，其实鼓励使用组合来完成功能，认为两个不同实例拥有继承关系，因此隐含了大量重复的代码是危险的行为。trait 跟接口很像，但 Java 的 interface 还可以定义函数行为，Rust 这里就不可以了。而且 Rust 教程里面也不会使用 interface 这样已有的词汇来描述 trait，因为 Rust 还有非常严格的类型系统，如果需要做容器的话，会用到很多 trait 提供的能力，比如 Box dyn 之类的。</p>
<pre lang="source"><code>trait AppendBar {
    fn append_bar(self) -&gt; Self;
}

impl AppendBar for String {
    //Add your code here
    fn append_bar(mut self) -&gt; Self {
        self = self + &amp;&quot;Bar&quot;.to_string();
        self
    }
}
</code></pre>
<p>上面为 String 增加了 append_bar 的接口，添加固定的 &quot;Bar&quot; 后缀。</p>
<p>因为 Rust 的编译器需要在编译期知道所有变量的大小，对于容器来说，是通过 Box 包裹来描述。Rust 为了实现零成本的抽象，泛型的处理实际上很多时候是编译期展开的，只有一些特殊的情况才是运行期动态决定的，这里我了解不深，先略过。</p>
<h3>宏</h3>
<p>Rust 的宏跟 C/C++ 的 define 完全不同，因为不懂 C++ 的 template，所以也回答不上是否拥有 template 这么强大的元编程能力。同样作为元编程，能力强是真的，这个部分我还看不大懂，大概了解到，Rust 宏在 AST 构建完成后才展开，能捕捉下面这些元素</p>
<pre lang="source"><code>item: an item, like a function, struct, module, etc.
block: a block (i.e. a block of statements and/or an expression, surrounded by braces)
stmt: a statement
pat: a pattern
expr: an expression
ty: a type
ident: an identifier
path: a path (e.g. foo, ::std::mem::replace, transmute::&lt;_, int&gt;, …)
meta: a meta item; the things that go inside #[...] and #![...] attributes
tt: a single token tree
</code></pre>
<p>举个例子，下面 vec! 宏捕捉了 expr，push 每个 x</p>
<pre lang="source"><code>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
&lt;a id=&quot;[macro_export]&quot;&gt;&lt;/a&gt;

macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre>
<p>例子都来自 <a href="https://danielkeep.github.io/tlborm/book/README.html">The Little Book of Rust Macros</a></p>
<h3>字符串</h3>
<p>Rust 内建了 str 类型，表示字符串的纸面含义，是输入字符串原来的值，String 是一个 std 类，内部是 UTF-8 编码的字符串，char 在 Rust 实现是 4 个字节的 UNICODE。</p>
<p>做习题的时候，经常性的 String::From(&quot;abc&quot;) 或者 a.to_string()，习题里面的 char 倒是很少用。</p>
<p>感觉字符串在哪一种语言都不是一个简单的事情，现在都是全球化了，考虑字符串是一种输入，可能是任何一种语言，因此其长度、分割、排版显示都不是小事情。</p>
<h3>迭代器</h3>
<p>Rust 中每种容器都有迭代器，即便是 (0..10) 表示 0 - 9，(0..=10) 表示 0 - 10，可以下面这样用</p>
<pre lang="source"><code>pub fn factorial(num: u64) -&gt; u64 {
    if num &lt;= 0 {
        0
    } else {
        (1..=num).fold(1, |acc, x| acc * x)
    }
}

assert_eq!(24, factorial(4));
</code></pre>
<p>上面的斐波那契数列计算，没有用到多余的变量，没有用到 for、while、loop 和递归，只用了 Rust 里面的 fold 累加器，其他的还有 sum、filter、map 等，还有，上面忘了说的，expression 放到最后，就直接返回计算的值了。</p>
<p>--</p>
<p>举了好几个跟我之前了解的编程语言大不相同的例子，其实除此之外，还有不少，一些是我还不了解的，比如生命周期，比如 unsafe pointer，生命周期的描述是可以根据一些 trait 控制来改变的。Rust 性能优先，还考虑能高效调用 C 接口，unsafe pointer 是在 Rust 的借用模型、寿命周期外，自己控制程序的行为，毕竟需要调用 C 的接口等等。性能优先，因此零成本抽象、宏等等都是在这个基础上展开的，动态的部分不能说没有，只能说场景很少了。</p>
<p>这两天的心得，大概是这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2020-09.html#p1">Permalink</a></div>
<!-- Page published by cmark-gfm ends here -->
<div id="foot">2004-<script type="text/javascript">var d = new
	Date();document.write(d.getFullYear())</script> &copy;
	Sucha. Powered by MarkdownProjectCompositor.
</div>
</div><!-- sidebar -->
  <div id="sidebar">
      <p class="header">Here</p>
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="index.html">Front</a></li>
        <li><a href="../scratch/ThisSite.html">This Site</a></li>
        <li><a href="../live/AboutMe.html">About Me</a></li>
      </ul>

      <p class="header">Search</p><!-- Bing Search -->
      <form id="searchform" method="get" action="http://cn.bing.com/search" >
	<p><input id="searchtext" type="text" name="q" value="" /></p>
	<p><input type="hidden" name="ie" value="utf-8" /></p>
	<p><input type="hidden" name="oe" value="utf-8" /></p>
	<p><input type="hidden" name="hl" value="zh-CN" /></p>
	<p><input type="hidden" name="domains" value="suchang.net" /></p>
	<p><input name="si" type="hidden" value="suchang.net" /></p>
	<p><input type="hidden" name="sitesearch" value="suchang.net" /></p>
      </form>

      <p class="header">Contact</p>
        <ul>
          <li><a href="mailto:suchaaa@gmail.com">Mail me</a></li>
        </ul>

      <p class="header">Categories</p>

      <ul>
        <li><a href="CategoryLinux.html">GNU/Linux</a></li>
        <li><a href="CategoryProgramming.html">Programming</a></li>
        <li><a href="CategoryLife.html">Life &#38; essay</a></li>
        <li><a href="CategoryStatistics.html">Statistics</a></li>
        <li><a href="CategoryReading.html">Reading</a></li>
	     <li><a href="CategoryThisSite.html">This Site</a></li>
        <li><a href="CategoryMisc.html">Misc</a></li>
      </ul>

      <p class="header">Links</p>
      <ul>
        <li><a href="http://blog.csdn.net/g9yuayon/">G9</a></li>
        <li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
        <li><a href="http://blog.codingnow.com/">CloudWu</a></li>
        <li><a href="http://www.google.cn/maps/@22.6273208,110.1513288,15540m/data=!3m1!1e3?hl=zh-CN">Yulin City</a></li>
      </ul>

      <p class="header">Archives</p><div class="archive_links"><ul><li><a href="2021-03.html">March 2021</a></li><li><a href="2021-02.html">February 2021</a></li><li><a href="2021-01.html">January 2021</a></li><li><a href="2020-12.html">December 2020</a></li><li><a href="2020-11.html">November 2020</a></li><li><a href="2020-10.html">October 2020</a></li><li><a href="2020-09.html">September 2020</a></li><li><a href="2020-08.html">August 2020</a></li><li><a href="2020-07.html">July 2020</a></li><li><a href="2020-06.html">June 2020</a></li><li><a href="2020-05.html">May 2020</a></li><li><a href="2020-04.html">April 2020</a></li><li><a href="2020-02.html">February 2020</a></li><li><a href="2020-01.html">January 2020</a></li><li><a href="2019-12.html">December 2019</a></li><li><a href="2019-11.html">November 2019</a></li><li><a href="2019-10.html">October 2019</a></li><li><a href="2019-09.html">September 2019</a></li><li><a href="2019-08.html">August 2019</a></li><li><a href="2019-07.html">July 2019</a></li><li><a href="2019-06.html">June 2019</a></li><li><a href="2018-11.html">November 2018</a></li><li><a href="2018-09.html">September 2018</a></li><li><a href="2018-06.html">June 2018</a></li><li><a href="2018-05.html">May 2018</a></li><li><a href="2018-03.html">March 2018</a></li><li><a href="2018-01.html">January 2018</a></li><li><a href="2017-12.html">December 2017</a></li><li><a href="2017-09.html">September 2017</a></li><li><a href="2017-08.html">August 2017</a></li><li><a href="2017-06.html">June 2017</a></li><li><a href="2017-05.html">May 2017</a></li><li><a href="2017-04.html">April 2017</a></li><li><a href="2017-03.html">March 2017</a></li><li><a href="2017-02.html">February 2017</a></li><li><a href="2016-10.html">October 2016</a></li><li><a href="2016-05.html">May 2016</a></li><li><a href="2016-01.html">January 2016</a></li><li><a href="2015-12.html">December 2015</a></li><li><a href="2015-11.html">November 2015</a></li><li><a href="2015-10.html">October 2015</a></li><li><a href="2015-09.html">September 2015</a></li><li><a href="2015-08.html">August 2015</a></li><li><a href="2015-07.html">July 2015</a></li><li><a href="2015-06.html">June 2015</a></li><li><a href="2015-05.html">May 2015</a></li><li><a href="2015-03.html">March 2015</a></li><li><a href="2015-02.html">February 2015</a></li><li><a href="2015-01.html">January 2015</a></li><li><a href="2014-12.html">December 2014</a></li><li><a href="2014-05.html">May 2014</a></li><li><a href="2014-04.html">April 2014</a></li><li><a href="2014-03.html">March 2014</a></li><li><a href="2014-02.html">February 2014</a></li><li><a href="2014-01.html">January 2014</a></li><li><a href="2013-12.html">December 2013</a></li><li><a href="2013-11.html">November 2013</a></li><li><a href="2013-10.html">October 2013</a></li><li><a href="2013-09.html">September 2013</a></li><li><a href="2013-08.html">August 2013</a></li><li><a href="2013-07.html">July 2013</a></li><li><a href="2013-06.html">June 2013</a></li><li><a href="2013-05.html">May 2013</a></li><li><a href="2013-04.html">April 2013</a></li><li><a href="2013-03.html">March 2013</a></li><li><a href="2013-02.html">February 2013</a></li><li><a href="2013-01.html">January 2013</a></li><li><a href="2012-12.html">December 2012</a></li><li><a href="2012-11.html">November 2012</a></li><li><a href="2012-10.html">October 2012</a></li><li><a href="2012-08.html">August 2012</a></li><li><a href="2012-07.html">July 2012</a></li><li><a href="2012-06.html">June 2012</a></li><li><a href="2012-05.html">May 2012</a></li><li><a href="2012-04.html">April 2012</a></li><li><a href="2012-03.html">March 2012</a></li><li><a href="2012-02.html">February 2012</a></li><li><a href="2012-01.html">January 2012</a></li><li><a href="2011-12.html">December 2011</a></li><li><a href="2011-11.html">November 2011</a></li><li><a href="2011-10.html">October 2011</a></li><li><a href="2011-09.html">September 2011</a></li><li><a href="2011-08.html">August 2011</a></li><li><a href="2011-04.html">April 2011</a></li><li><a href="2011-02.html">February 2011</a></li><li><a href="2011-01.html">January 2011</a></li><li><a href="2010-12.html">December 2010</a></li><li><a href="2010-11.html">November 2010</a></li><li><a href="2010-09.html">September 2010</a></li><li><a href="2009-07.html">July 2009</a></li><li><a href="2009-06.html">June 2009</a></li><li><a href="2009-05.html">May 2009</a></li><li><a href="2009-04.html">April 2009</a></li><li><a href="2009-02.html">February 2009</a></li><li><a href="2009-01.html">January 2009</a></li><li><a href="2008-12.html">December 2008</a></li><li><a href="2008-11.html">November 2008</a></li><li><a href="2008-10.html">October 2008</a></li><li><a href="2008-09.html">September 2008</a></li><li><a href="2008-08.html">August 2008</a></li><li><a href="2008-07.html">July 2008</a></li><li><a href="2008-06.html">June 2008</a></li><li><a href="2008-05.html">May 2008</a></li><li><a href="2008-04.html">April 2008</a></li><li><a href="2008-03.html">March 2008</a></li><li><a href="2008-02.html">February 2008</a></li><li><a href="2008-01.html">January 2008</a></li><li><a href="2007-10.html">October 2007</a></li><li><a href="2007-07.html">July 2007</a></li><li><a href="2007-06.html">June 2007</a></li><li><a href="2007-05.html">May 2007</a></li><li><a href="2007-04.html">April 2007</a></li><li><a href="2007-03.html">March 2007</a></li><li><a href="2007-02.html">February 2007</a></li><li><a href="2007-01.html">January 2007</a></li><li><a href="2006-12.html">December 2006</a></li><li><a href="2006-11.html">November 2006</a></li><li><a href="2006-10.html">October 2006</a></li><li><a href="2006-09.html">September 2006</a></li><li><a href="2006-08.html">August 2006</a></li><li><a href="2006-07.html">July 2006</a></li><li><a href="2006-06.html">June 2006</a></li><li><a href="2006-05.html">May 2006</a></li><li><a href="2006-04.html">April 2006</a></li><li><a href="2006-03.html">March 2006</a></li><li><a href="2006-02.html">February 2006</a></li><li><a href="2006-01.html">January 2006</a></li><li><a href="2005-12.html">December 2005</a></li><li><a href="2005-11.html">November 2005</a></li><li><a href="2005-10.html">October 2005</a></li><li><a href="2005-09.html">September 2005</a></li><li><a href="2005-08.html">August 2005</a></li><li><a href="2005-07.html">July 2005</a></li><li><a href="2005-06.html">June 2005</a></li><li><a href="2005-05.html">May 2005</a></li><li><a href="2005-04.html">April 2005</a></li><li><a href="2005-03.html">March 2005</a></li><li><a href="2005-02.html">February 2005</a></li><li><a href="2005-01.html">January 2005</a></li><li><a href="2004-12.html">December 2004</a></li><li><a href="2004-11.html">November 2004</a></li><li><a href="2004-10.html">October 2004</a></li><li><a href="2004-09.html">September 2004</a></li></ul></div></div><!-- sidebar -->
   </div> <!-- body -->
  </body>
</html>