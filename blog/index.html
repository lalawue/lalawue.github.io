<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8">
    <title>Sucha's Blog - Welcome</title>
    <meta name="generator" content="MarkdownProjectCompositor.lua">
    <meta name="author" content="Sucha">
    <meta name="keywords" content="suchang, programming, Linux, Lua">
    <meta name="description" content="Sucha's blog">
    <link rel="shortcut icon" href="../images/ico.png">
    <link rel="stylesheet" type="text/css" href="../styles/blog.css">
    <link rel="stylesheet" type="text/css" href="../styles/prism.min.css">
    <style id="site_theme"></style>
  </head>
  <body>
    <div id="body">
      <div id="text">
	   <!-- Page published by cmark-gfm begins here --><h1>Sucha's Blog ~ Welcome</h1><div class="date">25年7月28日 周日 13:53</div>
<h2>泥潭</h2>
<p>朋友给介绍的小说，这本小说的特点在于故事线，分三个部分，分别从同一事件的三个不同人物（角色）来围绕故事展开。</p>
<p>故事的背景是辛亥革命，主角 1 是其中的保皇派，主角 2 是其中的光复会成员（刚开始留日的时候是带着小辫子，之后逐渐转向了革命），主角 3 是神父，三个不同角色用不同的叙述、表现方式，展开了故事。</p>
<p>故事还可以，最特别的是三个角色，三种不同的叙述方式，以及三条时间线，值得一看吧。</p>
<p>不过，故事叙述比较宏大，像我，得花不少时间才能理清其中的故事线了。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2025-07.html#p2">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年7月19日 周六 20:32</div>
<h2>目录文件索引思考</h2>
<p>比如录像文件循环覆盖的逻辑，按照日分割建立文件夹，之后需要考虑如果存储空间不够，需要删除文件或目录，以及按照时间戳可以快速定位文件。</p>
<p>目前了解到的是都只有纯目录、文件的遍历操作，以及没有空间之后，删除日目录下，某个二级目录，作为存储空间的释放（获取）逻辑。</p>
<p>纯目录、文件的遍历操作，因为是嵌入式，nand 访问 IO 口速率比较低，以及 cpu 较差，所以时间上很慢，接口上为了适应这个限制，限制为 255 个文件后一次返回，之后客户端再次请求，传递进去的参数，是上一次返回的最后一个节点的结束时间。</p>
<p>如果类似 windows thumbs 或者 mac os DS_Store 的缓存文件索引策略，我觉得可以改善这个问题。</p>
<p>创建资源文件前，先创建（更新）索引文件，标记为待完成，资源文件完成后 ，再标记为已完成（open 接口，bit 反转），删除文件目录释放存储空间的时候，也同样更新相关标记就行。</p>
<p>若索引文件损坏或者不可用，逻辑上可以回退到纯目录、文件的遍历操作。</p>
<p>特别是文件查找，如果定义索引文件在日目录一级，日目录里面的文件可以根据二分查找，是相当快的，应该比目录遍历快得多，毕竟只需要读取一个索引文件。</p>
<p>索引文件的更新可能导致损坏，因此我才建议用 open 接口，bit 翻转，用先、后标记来保证，如果没有后标记，更精细的做法是校验相关资源文件，若文件是完整的，则可以更新后标记。</p>
<p>同样的，删除也可以用先、后标记来做，这个都没什么问题。</p>
<p>我觉得这样的操作是安全的，以及通过索引文件来定位、遍历资源文件内容是高效的。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2025-07.html#p1">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年7月13日 周日 23:11</div>
<h2>嵌入式系统文件更新的一些思考</h2>
<p>目前公司产品（一款嵌入式产品）的固件更新，是使用刷固件（实际上是写固定大小的 jffs2 分区）来做的，大概了解到其更新逻辑是，校验下载后的固件压缩包，校验解压后的固件文件系统包，重启更新（其实还需要教研一次固件文件系统包），刷固件到固定大小的 nand  flash 分区（这个时候还需要校验一次），之后再次重启，挂载相关的 jffs2 分区。</p>
<p>实话说，相对于后端 go 这样 static linked 的程序更新（shipping），固件程序的更新实在是太麻烦了，一方面 nand 存储不可靠（虽然 SD 卡等 nand 存储，主控本身保证了数据安全），另外一方面，文件系统挂载为只读处理也是问题，以及刷机，多次重启，很耗费时间，从最开始的 5 分钟慢慢成了现在的 10 分钟。</p>
<p>所以，我想能否改成这样的逻辑：</p>
<p>比如类似 nginx -r 重启加载某个进程（假设都是 linux 的系统），一个 master 进程，下面多个 app 进程（看业务需求），更新逻辑是：</p>
<ul>
<li>kill 掉业务 app 进程（可能是多个），拉起更新（刷新）进程</li>
<li>卸载 app 业务分区（假设仍是 jffs2）</li>
<li>校验固件压缩包，校验固件解压包，写入 jffs2 分区，校验 app 业务分区</li>
<li>重新挂载 jffs2 分区</li>
<li>kill 掉刷新进程，拉起业务进程 loading 进程</li>
<li>loading 进程每次启动（包括冷启动，热启动），都会校验 app 业务分区，然后再拉起 app 多个业务</li>
</ul>
<p>这样，用多进程的方式来进行热更新，其效率会比目前冷启动的效率高得多，当然这里面有不少细节需要确认</p>
<ul>
<li>app 业务分区，在多个业务进程被 kill 掉后，是能够被卸载的</li>
<li>app 业务分区被卸载后，能够被正常写入（或者挂载为 RW 分区，直接更新二进制包，启动只校验二进制包，其实也就是 .so）</li>
<li>app 业务分区有最新的 .so，worker 加载失败后，master 进程能够拉起非更新分区的旧版的 app 业务进程，并通知到 HOST 支持再次更新</li>
</ul>
<p>这样 HOST 仍能随时更新固件里面的业务进程，这要比单纯仅只读 jffs2 挂载的业务分区，更新的效率高得多。</p>
<p>当然，上述的想法，是基于一些我对固件更新的业务逻辑的了解上，做出的一些改进。</p>
<p>距离我上次在福建做类似的固件开发（linux 嵌入式业务开发），已经超过了 13 年，之前的两个不同产品的更新，一个是完全依赖网络（网卡的 IPXE），一个是 EEPROM，然后再带 nand flash（忘记多大了），跟现在的应该是有差别。</p>
<p>大概思路是这样，如果有可能的话，我觉得改进的效率是很高的，应该要比现在 10 分钟起步的更新快得多得多，但是要求是 linux 的多进程管理，以及同步的能力吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2025-07.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年6月15日 周日 21:15</div>
<h2>凡人修仙传(2)</h2>
<p>是从 B 站的动画开始看的，一开始的动画有点粗糙，到后来大概八九十集，还是百来集的时候，4K 动画的精致程度，已经无与伦比，故事情节更是扣人心弦，每周一集的更新进度，让人等不及。</p>
<p>于是开始看小说了，之前买的汉王 10.3 寸屏纸质书开始派上用场，看书的效果、效率、手感都很不错，相当好评，只是我看小说的进度还是偏慢，大概只看了 1/10，远远赶不上动画的进度。</p>
<p>这篇网络小说我是大大推荐的，故事情节很不错。</p>
<p>当然动画更是大大推荐，故事情节相比小说，还优化了，动画效果更进一步，我觉得当前同期的动画，灵笼第二季的动画效果也远比不上现在的凡人修仙传，不过凡人修仙传每集的长度大概 20 分钟，灵笼大概有 40 分钟，以及凡人修仙传也不是每个角色都能得到这样精致的动效，只有稍微中心点的人物才会得到这样的资源投入。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2025-06.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年5月24日 周六 19:55</div>
<h2>iOS 下图表的绘制</h2>
<p>工作中碰到，没有用之前支持 K 线的第三方库，而是自己摸索了一下，因为需求也没有高的要求。</p>
<h3>UIBezierPath 曲线的平滑</h3>
<p>用直线绘制其实也是可以的，相交部分用圆角过度还行，但只就美观效果来说，跟曲线的拟合相比差远了。</p>
<p>可惜 iOS 下绘制曲线用的 UIBezierPath 仅支持有限点的控制，后台下发的数据可不止那几个点，这个时候就用到下面说的曲线的平滑了。</p>
<p>网上说到的曲线平滑算法有不少，而我只会使用 UIBezierPath 来绘制，github 上找到的有 2、3 个都是可以用的，比如下面这个：</p>
<ul>
<li>https://github.com/Ramshandilya/Bezier</li>
</ul>
<p>绘制出来的还是挺好看的，唯一的缺点在于，虽然都经过了数据点，但数据点并不是在区域范围的极值点上，也就是说，数据点在曲线里面不是曲线的最高、最低点，曲线的最高、最低值，在数据集的范围之外，这就挺不好的。</p>
<p>不过就曲线平滑这一点看，上面这个库还是很好用的。</p>
<h3>X、Y 值的放大、缩小比例</h3>
<p>二维的图表，为了在一张图表上表示所有的数据点，X、Y 轴上是需要刻度单位的，在 app 上虽然各图表的大小都一样，但是可能喂进去的数据各不相同，很多时候，并不需要同样的刻度来表现曲线，否则有的曲线，在刻度间隔较大的情况下，视觉上更像一条直线，表现不出具体的变化了。</p>
<p>这个时候需要将 Y 轴的刻度变小，以上原因，不管是 X 轴、Y 轴，都需要根据数据集的范围，选择一个合理的刻度变化（在 UI 大小相同、而数据集不同的情况下）。</p>
<h3>数据集到 UI、UI 到数据集的比例映射</h3>
<p>我记得之前看的第三方库，用的是 matrix 来做变换的，我自己操作的过程中，没有懂这个，反正都是线性的，索性单独建立 X、Y 轴的比例映射了。</p>
<p>就是转换的时候麻烦一点，显示的时候是 data -&gt; ui mapping，用户选择图表点的时候，是 ui -&gt; data mapping。</p>
<p>以上，就是手搓 iOS 图表绘制的几个要点了，最困难的点，是使用 UIBezierPath 曲线来平滑，得用到看不懂的代码，可选的方案是绘制直线，转交点用 round 来做，效果吧，勉勉强强，也是能用的。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2025-05.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年4月20日 周日 12:09</div>
<h2>凡人修仙传（1）</h2>
<p>很早就听说了凡人修仙传小说，但当时不喜好网络小说，就没读。现在 B 站有凡人修仙的番剧，心痒痒，就从第一集看了起来。</p>
<p>先说动画质量，明显第一集时候的动画质量相当一般，但是看到后面，大概七八十集的时候，动画质量好不少了，到了目前的一百四十集，乖乖，动画质量都不能用好来形容了，简直不能更好了。</p>
<p>4K 画质下，人物模型的精细程度，AOE 攻击的效果，我感觉都是拉满的，对比最新一档的哪吒3，都不会输，而这个是每周更新的番剧，这个质量也太好了吧。对比一些日漫有名的老动画，在效果上，老动画没法看。</p>
<p>我现在都犹豫着要不要读一遍小说算了，因为动画番剧一周一集的更新太慢了，太难等了。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2025-04.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年3月23日 周日 21:04</div>
<h2>AUGraph (1)</h2>
<p>说到 iOS 的音频播放，以及录音部分，之前我从未接触过，之前的音视频处理简单点说，其实就是纯 MP4 流的播放，要么是 AVPlayItem 用 https URL 的 mp4、要么是 HLS，反正都是其他组同事封装好的库。</p>
<p>现在遇到的是纯音频的处理，好不容易网上搜到了 2 篇相关的介绍：</p>
<ul>
<li><a href="https://blog.csdn.net/CSDNedu/article/details/143510532">01｜iOS平台音频渲染（一）：使用AudioQueue渲染音频</a></li>
<li><a href="https://blog.csdn.net/CSDNedu/article/details/143510539">02｜iOS平台音频渲染（二）：使用 AudioUnit 渲染音频</a></li>
</ul>
<p>但是总有些限制，比如因为更倾向于 8KHz 的输出（低质量的人声），导致 AudioQueue 其实要处理起来也复杂，反正按照网上的东拼西凑的教程，没能搞好从 48KHz 转 8KHz 的 PCM 流。</p>
<p>倒是在 github 上找到了使用 AUGraph 的方案，使用 AUGraph 串联起一个 AudioUnit（貌似不需要 AUGraph 也是可以的），每个 AudioUnit 包含 input（录音）、output（播放）两个 path（大概意思）。</p>
<p>每个 path 又涉及到输入、输出，比如对于播放，输入就是提供 PCM 流，输出则是连接到硬件喇叭、耳机、蓝牙等等。对于录音，输入则是硬件录音，输出则是转频率后的 PCM 流。</p>
<p>这样就很方便了。</p>
<p>当然细节上，还有 AVAudioSession 的处理，其实算是一个独占或者公用音频硬件资源的配置管理类，大概意思。</p>
<p>但仅仅这样是不够的，因为如果距离较近，则环境音、人声都可能导致回音，苹果硬件给提供了一个降人声回声的处理，但感觉没啥用；另外就是很容易就遇到啸叫的问题，而苹果是没有提供这方面的处理的。</p>
<p>有些声音处理的第三方库貌似对啸叫有抑制的作用，但我看了一下源码，其实也是 AUGraph 组的，没能看出如何处理啸叫的，让人头痛。</p>
<p>还有就是硬件转码 48KHz 到 8KHz，感觉质量有点差，原因不清楚。</p>
<p>反正效果一般般，大概这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2025-03.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年2月28日 周日 22:26</div>
<h2>三角洲行动</h2>
<p>春节前迷上了三角洲行动，还买了 2 个月的高级安全箱，但是水平实在有限，大部分的情况下，只能当个小糖人，虽然拿了不少大红，但实际上我是想找一个 CS 的平替，那么多枪可以玩，刚入坑感觉也是蛮好的。</p>
<p>但是现实中的大坝会教你做人，特别是机密大坝，摸金模式下，要自己计算装备价值，装备越好，秒人越快，这也得看系统给你的匹配对手，有时候再好的枪，也有没能扣动扳机就倒下的可能，特别是面对行政楼的牢大时，锁你的头无可奈何，得真刀上去实干。</p>
<p>跟线上朋友去过几次巴克什，一直拖后腿，只好退回大坝，自己去过一两次航天，死的莫名其妙，又退回大坝。</p>
<p>相比 CS，入坑要困难许多，对于年轻人应该没啥问题，特别是玩吃鸡过来的，腰射，举枪瞄准等等，还有左右晃头，对于直接 CS 一步到位的人，要熟悉的可太多了。</p>
<p>摸金模式下，要非常小心，才能用低装备打高风险对手，毕竟时间就是多射的几发子弹，出其不意，才能趁其不备。</p>
<p>话虽然是这么说，即便是有最低装备要求的机密大坝，也试过几乎没有收获的行动，有时候是我们半途加入，对方早就摸空了，还有就是第一个去到，5 秒之后立即短兵相接，给你思考的时间，只有短短的不到 10 秒钟，感觉要是上班，一天玩不了几轮。</p>
<p>所以，即便是最低限度的拿红，其实概率也没有想象中高，再说那么累偷摸进，偷摸出，小糖人拿红可太累了。但是因为自己的竞技水平问题，跟别人对枪，胜算很小，其实也没有什么游戏中的出路，只有当小糖人，被别人打，但是又不是每次进去能拿什么东西，接触时间很短对战就结束，但要从地图边缘进入到密集对战区，又需要很长时间，最后磨掉了耐心。</p>
<p>哎，就是公司加班变多不得不放下了。</p>
<p>大战场玩过不少，但是里面机哥太多了，前面几局对面都是机哥小糖人，逗你开心，到了后面，发现是我方机哥都缩着不动，还有各种穿墙、消失看的太多，举报也很难，对方的名字你都看不到，有没沙你，咋举报呀。</p>
<p>见过太多，类似于一夫当关、万夫莫开的，几十号人持续不断冲击，打不过对方一个人的，有死亡录像都打不过，这个就难评，不如自动划一个死亡禁区好了。还有对方有时候赢得莫名其妙的，人家算的很准，前面都硬推不动我方的，后面人家一堆人过来冲一波占了据点，很快游戏就结束了，这。。。</p>
<p>我还不如去摸金模式呢，我好歹还是个小糖人呢，大战场是真的四得不明不白的。</p>
<p>吐槽完毕，貌似有 3 周没玩了，戒了。</p>
<div class="category"><a href="CategoryLife.html">CategoryLife</a> / <a href="2025-02.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年1月26日 周日 22:39</div>
<h2>WSL2 的网络配置</h2>
<p>之前在 Win 11 23H 搞好的 Ubuntu 18.04 LTS 的网络配置，回到家里，又死活连不上了，原因未知，于是重新记录一下吧。</p>
<p>Window 侧</p>
<pre><code class="language-sh"> type .\.wslconfig
[wsl2]
networkingMode=bridged
vmSwitch=WSLBridge
ipv6=false
</code></pre>
<p>WSL2 这边之前按就安装好了 sshd，但是设置了不支持密码登陆，而是用 ssh 公钥登录，关键配置是：</p>
<pre><code class="language-sh"># To disable tunneled clear text passwords, change to no here!
PasswordAuthentication no
#PermitEmptyPasswords no

# Change to yes to enable challenge-response passwords (beware issues with
# some PAM modules and threads)
ChallengeResponseAuthentication no
</code></pre>
<p>然后支持 vscode 使用 Remote - SSH 连接，但是 Putty 用的自己的 SSH 方案的，还没搞懂要怎么连接。</p>
<p>不过不管咋说，用 vscode 写这个 blog 没啥问题。</p>
<div class="category"><a href="CategoryLinux.html">CategoryLinux</a> / <a href="2025-01.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年11月30日 周六 10:57</div>
<h2>SwiftSQLiteORM</h2>
<p>地址在 <a href="https://github.com/lalawue/SwiftSQLiteORM.git">https://github.com/lalawue/SwiftSQLiteORM.git</a>。</p>
<p>之前在公司实现过一个 Swift SQLite 的 ORM 库，基于 <a href="https://github.com/groue/GRDB.swift">GRDB</a>，ORM 的优势就是方便，不用自己 CURD，也能享受到关系数据库的 ACID（原子性、一致性、完整性与持久性）能力。</p>
<p>只不过 ORM 的方式，搜索能力确实一般而已，比如不好自己组 SQL 搜索子句，以及 join 其他表，或者仅 select 输出某几列。</p>
<p>不过这个输出某几列没有实现的原因，倒不是不好组子句，只是 Swift 是有类型系统的，输出的额外的类型必须得先定义，这个其实跟已有的表结构可能完全不相同，所以省略不做的。</p>
<p>因为之前自己也重构过 Lua 的 SQLite 的 ORM，所以多少熟悉了这个部分（没办法，工作很大一部分就是熟能生巧，在限制场景和条件下找解决方案，一边摸索一边实践，顺利的话，条件满足后就可以输出，当然纯逻辑的的数学、理论物理等这些领域不熟悉，不发表意见）。</p>
<h3>使用介绍</h3>
<p>先给个定义的例子：</p>
<pre><code class="language-swift">    // nested struct will store as JSON string
    struct ExampleNested: Codable {
        let desc: String
        let index: Int
    }

    struct ExampleType: DBTableDef {
        let name: String
        let data: ExampleNested

        typealias ORMKey = Columns

        /// keep blank or return nil for using hidden 'rowid' column
        static var primaryKey: Columns? {
            return .name
        }

        enum Columns: String, DBTableKey {
            case name
            case data
        }
    }
</code></pre>
<p><code>ExampleType</code> 是需要支持 ORM 的结构，遵循 <code>DBTableDef</code>，可以是 struct 或者是 class，不要求遵循 Codable 协议。</p>
<p>如上也就定义了数据库中的表结构，其中使用 <code>DBTableKey</code> 定义了数据库中的字段类型（支持仅部分属性进入数据库），这里还额外定义了 primary key 是 name，这样就支持了后续的 <code>deletes([T]) </code> 的接口，可以直接传递需要删除的实例进去。</p>
<p>如果结构有嵌套的子结构，比如上面的 <code>ExampleNested</code>，则需要支持 Codable 协议，因为非内建字段类型 ，默认是 Blob，将 encode 为 JSON 后保存，否则将 throw error。</p>
<p>使用如下：</p>
<pre><code class="language-swift">    do {
        // insert / update
        let c = ExampleType(name: &quot;c&quot;, data: ExampleNested(desc: &quot;c&quot;, index: 1))
        let u = ExampleType(name: &quot;u&quot;, data: ExampleNested(desc: &quot;u&quot;, index: 2))
        try DBMgnt.push([c, u])

        // select
        let arr = try DBMgnt.fetch(ExampleType.self, .eq(.name, c.name))
        XCTAssert(arr.count == 1, &quot;failed&quot;)
        XCTAssert(arr[0].name == c.name, &quot;failed&quot;)

        // delete
        try DBMgnt.deletes([c]) // require primaryKey in table definition
        try DBMgnt.delete(ExampleType.self, .eq(.name, u.name))
        let count = try DBMgnt.fetch(ExampleType.self, .eq(.name, c.name)).count
        XCTAssert(count == 0, &quot;failed&quot;)

        // clear
        try DBMgnt.clear(ExampleType.self)

        // drop table
        try DBMgnt.drop(ExampleType.self)

    } catch {
        if let err = error as? DBORMError {
            fatalError(&quot;failed to try block: \(err.localizedDescription)&quot;)
        } else {
            fatalError(&quot;failed to try block: \(error.localizedDescription)&quot;)
        }
    }
</code></pre>
<p>CURD 基本上就是 push、fetch、deletes、delete、clear、drop 这样，其中 fetch、delete 接口支持 <code>DBRecordFilter</code>，关联 <code>DBTableDef</code> 中的字段定义，计算操作、比较操作都是可以传递属性名称进去的，类型则遵循 SQLite select 的类型转换规定，我大体理解是跟字段定义相关，比如 SQLite 给的字段定义可以是 TEXT、INTEGER、REAL、BLOB。</p>
<p>另外，我只实现了部分内建字段的映射定义，用户可以根据自己需要通过 <code>DBPrimitive</code> 协议，定义某些类型支持映射：</p>
<pre><code class="language-swift">/// database column type
/// - will perform relative type calculation in sql expression
/// - https://sqlite.org/datatype3.html
public enum DBStoreType {

    /// Int64
    case INTEGER

    /// Double
    case REAL

    /// String, Numeric
    case TEXT

    /// Data
    case BLOB
}

/// database store value type
/// - will sotre as type's DatabaseValueConvertible through GRDB
public enum DBStoreValue {

    /// box with int64
    case integer(Int64)

    /// box with double
    case real(Double)

    /// box with String
    case text(String)

    /// box with data
    case blob(Data)
}

/// type transform for store / restore from database
public protocol DBPrimitive: DefaultConstructor {

    /// database column type
    static var ormStoreType: DBStoreType { get }

    /// return TypeInfo for mocking, for example objc wrapper NSUUID
    static func ormTypeInfo() throws -&gt; TypeInfo

    /// mapping value to store in database
    func ormToStoreValue() -&gt; DBStoreValue?

    /// restore value from database
    static func ormFromStoreValue(_ value: DBStoreValue) -&gt; Self?
}
</code></pre>
<p>其中的 <code>DBStoreType</code> 是数据库列类型，<code>DBStoreValue</code> 则是将自定义字段的数据通过 String、Int64、Double 或者 Data 传递到数据库，以及读取的时候，数据库也将返回这几种数据，给自定义类型来恢复。</p>
<p>比如最开始例子的 name 属性是 String 类型，将映射为 SQLite 下的 TEXT 列类型。</p>
<p>比如下面例子的 URL 将映射为 TEXT 列类型：</p>
<pre><code class="language-swift">extension URL: DBPrimitive {

    public init() {
        // will be placed by database value later
        self.init(string: &quot;a://a.a&quot;)!
    }

    public static var ormStoreType: SwiftSQLiteORM.DBStoreType { .TEXT }

    public func ormToStoreValue() -&gt; SwiftSQLiteORM.DBStoreValue? {
        return .text(self.absoluteString)
    }

    public static func ormFromStoreValue(_ value: SwiftSQLiteORM.DBStoreValue) -&gt; URL? {
        guard case .text(let string) = value else {
            return nil
        }
        return URL(string: string)
    }
}
</code></pre>
<p>上面的例子都没有涉及到如何 connect 数据库，以及建立 table 等，因为这些 ORM 库都自动做了，甚至支持 alter table。</p>
<p>比如需要多增加一个属性，并记录到数据库，只需要升级 <code>DBTableDef</code> 下的 <code>tableVersion</code> 就好，是一个 Double 类型的字段。</p>
<p>当然还支持指定 table 名称，以及使用独立的数据库文件，如下：</p>
<pre><code class="language-swift">extension DBTableDef {

    /// ...

    /// specify table name or use type name
    /// - should be unique in all scope
    static var tableName: String { get }

    /// schema version for table columns, default 0
    /// - increase version after you add columns
    static var tableVersion: Double { get }

    /// specify database file name or use default
    static var databaseName: String { get }

    /// ...
}
</code></pre>
<h3>实现细节</h3>
<p>ORM 需要将 struct、class 的指定字段，映射到 SQLite 中的表结构，对应列的类型需要能保存属性数据，便于后续的计算、比较操作，这里对 Swift 语法结构的获取，用的库是 <a href="https://github.com/wickwirew/Runtime">Runtime</a>，这个也是我在 github 上遇到了 <a href="https://github.com/pozi119/SQLiteORM">SQLiteORM</a> 后，读取其代码了解到的。</p>
<p>从 Runtime 这个库，可以拿到 Swift 结构的属性列表，以及每一个属性的类型，甚至可以构造这个属性的实例。</p>
<p>比如 <code>fetch</code> 接口操作之后，这个实例的字段数据，是依赖数据库字段读取到的，因为 <code>DBTableDef</code> 支持仅保存部分字段，因此其他字段可以通过下面的函数由用户自己填充，或者使用默认值。</p>
<pre><code class="language-swift">/// Table ORM mapping definition
public protocol DBTableDef {

    /// ...

    /// update instance property value created by type reflection
    /// - only ORMKey covered property can restore value from database column
    /// - others property will use default value
    static func ormUpdateNew(_ value: inout Self) -&gt; Self
}
</code></pre>
<p>Swift 侧的表结构大致可以定义，但是数据库这边我偷懒了，不像 SQLiteORM 那样通过 SQLite 的接口组织操作，而是利用了 GRDB 来做保存、读取。</p>
<p>这次我用了 <code>GRDB.swift/SQLCipher</code> 来做底层存储操作接口，其中的加密用的 password phrase 是库自动生成后，保存到 keychain 里面的。所以每次重新安装后，password phrase 都会不一样，但不影响使用，用户侧也无需知道具体是什么。</p>
<p>GRDB 的读取是通过 Row 结构，使用上类似字典，保存的时候是通过 <code>encode</code>，也是类似字典，将属性保存到 container 中：</p>
<pre><code class="language-swift">    /// insert / update
    override func encode(to container: inout PersistenceContainer) {
        /// ...
    }
</code></pre>
<p>其中遇到的一些问题，以及不大好解决的问题记录大概有：</p>
<p>SQLite 不支持保存 UInt64，所以这个类型，我是保存为了 TEXT，记录、恢复当然是没有问题的，只是在计算、比较的时候，我大概理解 SQLite 应该是 cast 为了 TEXT 来进行比较的吧。对比之下，GRDB 几乎是不支持 UInt64。</p>
<p>NSDecimalNumber 其实在 Swift 里面就是 Decimal，但在 ObjC 里面，是 NSNumber 的子类，在 GRDB 里面，是被认为是 NSNumber，然后内部比较后来保存的，GRDB 对于 NSDecimalNumber 仅支持保存 &gt;=Int64.min 和 &lt;=Int64.max 的值。</p>
<p>而在本库 NSDecimalNumber 是作为 TEXT 保存，短板也是类似 UInt64。</p>
<p>同样的 NSNumber 本库也是作为 TEXT 保存，估计计算、比较的时候会有点问题吧，但基本存取操作在边界上是没啥问题的。</p>
<p>等于是将计算、比较任务，都扔给 SQLite 列类型来处理了，比如 Decimal 跟 Real 的比较，等于是 SQLite 中 TEXT 字段和输入 REAL 值的比较了。</p>
<p>也许这部分后续可以改进一下，利用 GRDB 的 argument 参数，使用 SQLite 的 bind 接口来完成，估计会更好一些，后面再说吧。</p>
<p>大概就是这样。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2024-11.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年10月27日 周日 19:21</div>
<h2>枢纽——3000年的中国</h2>
<p>这个大部头读了好久，主线是中华民族的发展史，以及当前取得的成就，结合地缘、历史的深入解读。</p>
<p><strong>枢纽</strong>是本书强调的中心点。</p>
<p>和美国海权国家（英国也是），俄罗斯陆权国家（德国也是）不同，中国是海陆复合型国家（伊朗也是），我们不仅有绵长的海岸线、广阔的南海，还有这跟中亚、蒙古等国家接壤的国界线，是欧亚大陆（世界岛）的重要国家。跟深入内陆中亚的交流，几千年前就开始了。</p>
<p>在中国的历史上，代表草原文明、农耕文明的各民族，在不同时期作为主线，开启了属于自己的朝代。不同的王朝，都有同样的考虑，如长久的统治、稳定的社会。因此统治时，必须同时考虑草原、农耕文明。在朝代更迭的历史发展中，草原、农耕文明你争我夺，最终融合。</p>
<p>王朝最终是草原、农耕文明的枢纽，只有这样，才能稳定这两种不同的力量。</p>
<p>作为拥有绵长海岸线的国家，王朝通过海洋跟世界其他地方的联系，早就有了规模。比如马来西亚、菲律宾的华人，当年因为各种原因下南洋，还保留着华人（社会）的很多传统，说明文明的传递，其实也跨越了海洋。不过我们近代对于海洋的争斗，比较吃亏，显得海洋方面的发展，比较落后而已。</p>
<p>之前王朝在繁荣发展，人口膨胀后，都会陷入马尔萨斯陷阱，遇到天灾人祸，脆弱的经济将导致崩溃，人口减少后才能平衡下来。</p>
<p>但是膨胀的人口，却不是都坏事。比如即便清朝，跟当时的工业国——英国的贸易，一直都是顺差。</p>
<p>因为当时庞大的人口，使得即便非工业化的手工制造业，成本都很低。因此当时初步的工业化，对于王朝来说，并不划算，没法形成规模，导致社会本身没有强烈的动力去进行工业化。而王朝的框架结构，也没法在社会内部被突破改变，最终是外部世界输入的变化，压垮了王朝。</p>
<p>而作为拥有统一的法律、庞大的受教育人口、巨大内部市场的大国，在如今的工业化时代，却是优势。</p>
<p>比如我们工业化成体系后，对应现代供应链网络的迭代、进化非常快（必须拥有统一法律、巨大内部市场、相当规模人口的大国才可能），在逐渐进化的同时，东南亚的供应链也逐渐融入（一方面文化相距不远方便吸收，另一方面为了规避制裁换个牌其实很快），使得在东亚的制造业规模化成本、优化迭代成本，是全世界最经济的，不仅足以供应全世界。其规模竞争优势，也要远远优于世界其他地方的工业化成本。</p>
<p>我们每天都在进口原材料、输出最经济的工业制成品、高科技产品，在当今社会，我们就是世界经济运转的枢纽。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2024-10.html#p1">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>
<!-- Page published by cmark-gfm ends here -->
  <div id="foot">2004-<script>var d = new
	Date();document.write(d.getFullYear())</script> &copy;
	Sucha. Powered by MarkdownProjectCompositor.
  </div>
  </div><!-- text -->
  <div id="sidebar">
  </div><!-- sidebar -->
  <script src="../js/prism.min.js" async="async"></script>
  <script src="../js/blog_sidebar.js"></script>
  </div> <!-- body -->
</body>
</html>