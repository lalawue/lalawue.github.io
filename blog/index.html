<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8">
    <title>Sucha's Blog - Welcome</title>
    <meta name="generator" content="MarkdownProjectCompositor.lua">
    <meta name="author" content="Sucha">
    <meta name="keywords" content="suchang, programming, Linux, Lua">
    <meta name="description" content="Sucha's blog">
    <link rel="shortcut icon" href="../images/ico.png">
    <link rel="stylesheet" type="text/css" href="../styles/blog.css">
    <link rel="stylesheet" type="text/css" href="../styles/prism.min.css">
    <style id="site_theme"></style>
  </head>
  <body>
    <div id="body">
      <div id="text">
	   <!-- Page published by cmark-gfm begins here --><h1>Sucha's Blog ~ Welcome</h1><div class="date">25年3月23日 周日 21:04</div>
<h2>AUGraph (1)</h2>
<p>说到 iOS 的音频播放，以及录音部分，之前我从未接触过，之前的音视频处理简单点说，其实就是纯 MP4 流的播放，要么是 AVPlayItem 用 https URL 的 mp4、要么是 HLS，反正都是其他组同事封装好的库。</p>
<p>现在遇到的是纯音频的处理，好不容易网上搜到了 2 篇相关的介绍：</p>
<ul>
<li><a href="https://blog.csdn.net/CSDNedu/article/details/143510532">01｜iOS平台音频渲染（一）：使用AudioQueue渲染音频</a></li>
<li><a href="https://blog.csdn.net/CSDNedu/article/details/143510539">02｜iOS平台音频渲染（二）：使用 AudioUnit 渲染音频</a></li>
</ul>
<p>但是总有些限制，比如因为更倾向于 8KHz 的输出（低质量的人声），导致 AudioQueue 其实要处理起来也复杂，反正按照网上的东拼西凑的教程，没能搞好从 48KHz 转 8KHz 的 PCM 流。</p>
<p>倒是在 github 上找到了使用 AUGraph 的方案，使用 AUGraph 串联起一个 AudioUnit（貌似不需要 AUGraph 也是可以的），每个 AudioUnit 包含 input（录音）、output（播放）两个 path（大概意思）。</p>
<p>每个 path 又涉及到输入、输出，比如对于播放，输入就是提供 PCM 流，输出则是连接到硬件喇叭、耳机、蓝牙等等。对于录音，输入则是硬件录音，输出则是转频率后的 PCM 流。</p>
<p>这样就很方便了。</p>
<p>当然细节上，还有 AVAudioSession 的处理，其实算是一个独占或者公用音频硬件资源的配置管理类，大概意思。</p>
<p>但仅仅这样是不够的，因为如果距离较近，则环境音、人声都可能导致回音，苹果硬件给提供了一个降人声回声的处理，但感觉没啥用；另外就是很容易就遇到啸叫的问题，而苹果是没有提供这方面的处理的。</p>
<p>有些声音处理的第三方库貌似对啸叫有抑制的作用，但我看了一下源码，其实也是 AUGraph 组的，没能看出如何处理啸叫的，让人头痛。</p>
<p>还有就是硬件转码 48KHz 到 8KHz，感觉质量有点差，原因不清楚。</p>
<p>反正效果一般般，大概这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2025-03.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年2月28日 周日 22:26</div>
<h2>三角洲行动</h2>
<p>春节前迷上了三角洲行动，还买了 2 个月的高级安全箱，但是水平实在有限，大部分的情况下，只能当个小糖人，虽然拿了不少大红，但实际上我是想找一个 CS 的平替，那么多枪可以玩，刚入坑感觉也是蛮好的。</p>
<p>但是现实中的大坝会教你做人，特别是机密大坝，摸金模式下，要自己计算装备价值，装备越好，秒人越快，这也得看系统给你的匹配对手，有时候再好的枪，也有没能扣动扳机就倒下的可能，特别是面对行政楼的牢大时，锁你的头无可奈何，得真刀上去实干。</p>
<p>跟线上朋友去过几次巴克什，一直拖后腿，只好退回大坝，自己去过一两次航天，死的莫名其妙，又退回大坝。</p>
<p>相比 CS，入坑要困难许多，对于年轻人应该没啥问题，特别是玩吃鸡过来的，腰射，举枪瞄准等等，还有左右晃头，对于直接 CS 一步到位的人，要熟悉的可太多了。</p>
<p>摸金模式下，要非常小心，才能用低装备打高风险对手，毕竟时间就是多射的几发子弹，出其不意，才能趁其不备。</p>
<p>话虽然是这么说，即便是有最低装备要求的机密大坝，也试过几乎没有收获的行动，有时候是我们半途加入，对方早就摸空了，还有就是第一个去到，5 秒之后立即短兵相接，给你思考的时间，只有短短的不到 10 秒钟，感觉要是上班，一天玩不了几轮。</p>
<p>所以，即便是最低限度的拿红，其实概率也没有想象中高，再说那么累偷摸进，偷摸出，小糖人拿红可太累了。但是因为自己的竞技水平问题，跟别人对枪，胜算很小，其实也没有什么游戏中的出路，只有当小糖人，被别人打，但是又不是每次进去能拿什么东西，接触时间很短对战就结束，但要从地图边缘进入到密集对战区，又需要很长时间，最后磨掉了耐心。</p>
<p>哎，就是公司加班变多不得不放下了。</p>
<p>大战场玩过不少，但是里面机哥太多了，前面几局对面都是机哥小糖人，逗你开心，到了后面，发现是我方机哥都缩着不动，还有各种穿墙、消失看的太多，举报也很难，对方的名字你都看不到，有没沙你，咋举报呀。</p>
<p>见过太多，类似于一夫当关、万夫莫开的，几十号人持续不断冲击，打不过对方一个人的，有死亡录像都打不过，这个就难评，不如自动划一个死亡禁区好了。还有对方有时候赢得莫名其妙的，人家算的很准，前面都硬推不动我方的，后面人家一堆人过来冲一波占了据点，很快游戏就结束了，这。。。</p>
<p>我还不如去摸金模式呢，我好歹还是个小糖人呢，大战场是真的四得不明不白的。</p>
<p>吐槽完毕，貌似有 3 周没玩了，戒了。</p>
<div class="category"><a href="CategoryLife.html">CategoryLife</a> / <a href="2025-02.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">25年1月26日 周日 22:39</div>
<h2>WSL2 的网络配置</h2>
<p>之前在 Win 11 23H 搞好的 Ubuntu 18.04 LTS 的网络配置，回到家里，又死活连不上了，原因未知，于是重新记录一下吧。</p>
<p>Window 侧</p>
<pre><code class="language-sh"> type .\.wslconfig
[wsl2]
networkingMode=bridged
vmSwitch=WSLBridge
ipv6=false
</code></pre>
<p>WSL2 这边之前按就安装好了 sshd，但是设置了不支持密码登陆，而是用 ssh 公钥登录，关键配置是：</p>
<pre><code class="language-sh"># To disable tunneled clear text passwords, change to no here!
PasswordAuthentication no
#PermitEmptyPasswords no

# Change to yes to enable challenge-response passwords (beware issues with
# some PAM modules and threads)
ChallengeResponseAuthentication no
</code></pre>
<p>然后支持 vscode 使用 Remote - SSH 连接，但是 Putty 用的自己的 SSH 方案的，还没搞懂要怎么连接。</p>
<p>不过不管咋说，用 vscode 写这个 blog 没啥问题。</p>
<div class="category"><a href="CategoryLinux.html">CategoryLinux</a> / <a href="2025-01.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年11月30日 周六 10:57</div>
<h2>SwiftSQLiteORM</h2>
<p>地址在 <a href="https://github.com/lalawue/SwiftSQLiteORM.git">https://github.com/lalawue/SwiftSQLiteORM.git</a>。</p>
<p>之前在公司实现过一个 Swift SQLite 的 ORM 库，基于 <a href="https://github.com/groue/GRDB.swift">GRDB</a>，ORM 的优势就是方便，不用自己 CURD，也能享受到关系数据库的 ACID（原子性、一致性、完整性与持久性）能力。</p>
<p>只不过 ORM 的方式，搜索能力确实一般而已，比如不好自己组 SQL 搜索子句，以及 join 其他表，或者仅 select 输出某几列。</p>
<p>不过这个输出某几列没有实现的原因，倒不是不好组子句，只是 Swift 是有类型系统的，输出的额外的类型必须得先定义，这个其实跟已有的表结构可能完全不相同，所以省略不做的。</p>
<p>因为之前自己也重构过 Lua 的 SQLite 的 ORM，所以多少熟悉了这个部分（没办法，工作很大一部分就是熟能生巧，在限制场景和条件下找解决方案，一边摸索一边实践，顺利的话，条件满足后就可以输出，当然纯逻辑的的数学、理论物理等这些领域不熟悉，不发表意见）。</p>
<h3>使用介绍</h3>
<p>先给个定义的例子：</p>
<pre><code class="language-swift">    // nested struct will store as JSON string
    struct ExampleNested: Codable {
        let desc: String
        let index: Int
    }

    struct ExampleType: DBTableDef {
        let name: String
        let data: ExampleNested

        typealias ORMKey = Columns

        /// keep blank or return nil for using hidden 'rowid' column
        static var primaryKey: Columns? {
            return .name
        }

        enum Columns: String, DBTableKey {
            case name
            case data
        }
    }
</code></pre>
<p><code>ExampleType</code> 是需要支持 ORM 的结构，遵循 <code>DBTableDef</code>，可以是 struct 或者是 class，不要求遵循 Codable 协议。</p>
<p>如上也就定义了数据库中的表结构，其中使用 <code>DBTableKey</code> 定义了数据库中的字段类型（支持仅部分属性进入数据库），这里还额外定义了 primary key 是 name，这样就支持了后续的 <code>deletes([T]) </code> 的接口，可以直接传递需要删除的实例进去。</p>
<p>如果结构有嵌套的子结构，比如上面的 <code>ExampleNested</code>，则需要支持 Codable 协议，因为非内建字段类型 ，默认是 Blob，将 encode 为 JSON 后保存，否则将 throw error。</p>
<p>使用如下：</p>
<pre><code class="language-swift">    do {
        // insert / update
        let c = ExampleType(name: &quot;c&quot;, data: ExampleNested(desc: &quot;c&quot;, index: 1))
        let u = ExampleType(name: &quot;u&quot;, data: ExampleNested(desc: &quot;u&quot;, index: 2))
        try DBMgnt.push([c, u])

        // select
        let arr = try DBMgnt.fetch(ExampleType.self, .eq(.name, c.name))
        XCTAssert(arr.count == 1, &quot;failed&quot;)
        XCTAssert(arr[0].name == c.name, &quot;failed&quot;)

        // delete
        try DBMgnt.deletes([c]) // require primaryKey in table definition
        try DBMgnt.delete(ExampleType.self, .eq(.name, u.name))
        let count = try DBMgnt.fetch(ExampleType.self, .eq(.name, c.name)).count
        XCTAssert(count == 0, &quot;failed&quot;)

        // clear
        try DBMgnt.clear(ExampleType.self)

        // drop table
        try DBMgnt.drop(ExampleType.self)

    } catch {
        if let err = error as? DBORMError {
            fatalError(&quot;failed to try block: \(err.localizedDescription)&quot;)
        } else {
            fatalError(&quot;failed to try block: \(error.localizedDescription)&quot;)
        }
    }
</code></pre>
<p>CURD 基本上就是 push、fetch、deletes、delete、clear、drop 这样，其中 fetch、delete 接口支持 <code>DBRecordFilter</code>，关联 <code>DBTableDef</code> 中的字段定义，计算操作、比较操作都是可以传递属性名称进去的，类型则遵循 SQLite select 的类型转换规定，我大体理解是跟字段定义相关，比如 SQLite 给的字段定义可以是 TEXT、INTEGER、REAL、BLOB。</p>
<p>另外，我只实现了部分内建字段的映射定义，用户可以根据自己需要通过 <code>DBPrimitive</code> 协议，定义某些类型支持映射：</p>
<pre><code class="language-swift">/// database column type
/// - will perform relative type calculation in sql expression
/// - https://sqlite.org/datatype3.html
public enum DBStoreType {

    /// Int64
    case INTEGER

    /// Double
    case REAL

    /// String, Numeric
    case TEXT

    /// Data
    case BLOB
}

/// database store value type
/// - will sotre as type's DatabaseValueConvertible through GRDB
public enum DBStoreValue {

    /// box with int64
    case integer(Int64)

    /// box with double
    case real(Double)

    /// box with String
    case text(String)

    /// box with data
    case blob(Data)
}

/// type transform for store / restore from database
public protocol DBPrimitive: DefaultConstructor {

    /// database column type
    static var ormStoreType: DBStoreType { get }

    /// return TypeInfo for mocking, for example objc wrapper NSUUID
    static func ormTypeInfo() throws -&gt; TypeInfo

    /// mapping value to store in database
    func ormToStoreValue() -&gt; DBStoreValue?

    /// restore value from database
    static func ormFromStoreValue(_ value: DBStoreValue) -&gt; Self?
}
</code></pre>
<p>其中的 <code>DBStoreType</code> 是数据库列类型，<code>DBStoreValue</code> 则是将自定义字段的数据通过 String、Int64、Double 或者 Data 传递到数据库，以及读取的时候，数据库也将返回这几种数据，给自定义类型来恢复。</p>
<p>比如最开始例子的 name 属性是 String 类型，将映射为 SQLite 下的 TEXT 列类型。</p>
<p>比如下面例子的 URL 将映射为 TEXT 列类型：</p>
<pre><code class="language-swift">extension URL: DBPrimitive {

    public init() {
        // will be placed by database value later
        self.init(string: &quot;a://a.a&quot;)!
    }

    public static var ormStoreType: SwiftSQLiteORM.DBStoreType { .TEXT }

    public func ormToStoreValue() -&gt; SwiftSQLiteORM.DBStoreValue? {
        return .text(self.absoluteString)
    }

    public static func ormFromStoreValue(_ value: SwiftSQLiteORM.DBStoreValue) -&gt; URL? {
        guard case .text(let string) = value else {
            return nil
        }
        return URL(string: string)
    }
}
</code></pre>
<p>上面的例子都没有涉及到如何 connect 数据库，以及建立 table 等，因为这些 ORM 库都自动做了，甚至支持 alter table。</p>
<p>比如需要多增加一个属性，并记录到数据库，只需要升级 <code>DBTableDef</code> 下的 <code>tableVersion</code> 就好，是一个 Double 类型的字段。</p>
<p>当然还支持指定 table 名称，以及使用独立的数据库文件，如下：</p>
<pre><code class="language-swift">extension DBTableDef {

    /// ...

    /// specify table name or use type name
    /// - should be unique in all scope
    static var tableName: String { get }

    /// schema version for table columns, default 0
    /// - increase version after you add columns
    static var tableVersion: Double { get }

    /// specify database file name or use default
    static var databaseName: String { get }

    /// ...
}
</code></pre>
<h3>实现细节</h3>
<p>ORM 需要将 struct、class 的指定字段，映射到 SQLite 中的表结构，对应列的类型需要能保存属性数据，便于后续的计算、比较操作，这里对 Swift 语法结构的获取，用的库是 <a href="https://github.com/wickwirew/Runtime">Runtime</a>，这个也是我在 github 上遇到了 <a href="https://github.com/pozi119/SQLiteORM">SQLiteORM</a> 后，读取其代码了解到的。</p>
<p>从 Runtime 这个库，可以拿到 Swift 结构的属性列表，以及每一个属性的类型，甚至可以构造这个属性的实例。</p>
<p>比如 <code>fetch</code> 接口操作之后，这个实例的字段数据，是依赖数据库字段读取到的，因为 <code>DBTableDef</code> 支持仅保存部分字段，因此其他字段可以通过下面的函数由用户自己填充，或者使用默认值。</p>
<pre><code class="language-swift">/// Table ORM mapping definition
public protocol DBTableDef {

    /// ...

    /// update instance property value created by type reflection
    /// - only ORMKey covered property can restore value from database column
    /// - others property will use default value
    static func ormUpdateNew(_ value: inout Self) -&gt; Self
}
</code></pre>
<p>Swift 侧的表结构大致可以定义，但是数据库这边我偷懒了，不像 SQLiteORM 那样通过 SQLite 的接口组织操作，而是利用了 GRDB 来做保存、读取。</p>
<p>这次我用了 <code>GRDB.swift/SQLCipher</code> 来做底层存储操作接口，其中的加密用的 password phrase 是库自动生成后，保存到 keychain 里面的。所以每次重新安装后，password phrase 都会不一样，但不影响使用，用户侧也无需知道具体是什么。</p>
<p>GRDB 的读取是通过 Row 结构，使用上类似字典，保存的时候是通过 <code>encode</code>，也是类似字典，将属性保存到 container 中：</p>
<pre><code class="language-swift">    /// insert / update
    override func encode(to container: inout PersistenceContainer) {
        /// ...
    }
</code></pre>
<p>其中遇到的一些问题，以及不大好解决的问题记录大概有：</p>
<p>SQLite 不支持保存 UInt64，所以这个类型，我是保存为了 TEXT，记录、恢复当然是没有问题的，只是在计算、比较的时候，我大概理解 SQLite 应该是 cast 为了 TEXT 来进行比较的吧。对比之下，GRDB 几乎是不支持 UInt64。</p>
<p>NSDecimalNumber 其实在 Swift 里面就是 Decimal，但在 ObjC 里面，是 NSNumber 的子类，在 GRDB 里面，是被认为是 NSNumber，然后内部比较后来保存的，GRDB 对于 NSDecimalNumber 仅支持保存 &gt;=Int64.min 和 &lt;=Int64.max 的值。</p>
<p>而在本库 NSDecimalNumber 是作为 TEXT 保存，短板也是类似 UInt64。</p>
<p>同样的 NSNumber 本库也是作为 TEXT 保存，估计计算、比较的时候会有点问题吧，但基本存取操作在边界上是没啥问题的。</p>
<p>等于是将计算、比较任务，都扔给 SQLite 列类型来处理了，比如 Decimal 跟 Real 的比较，等于是 SQLite 中 TEXT 字段和输入 REAL 值的比较了。</p>
<p>也许这部分后续可以改进一下，利用 GRDB 的 argument 参数，使用 SQLite 的 bind 接口来完成，估计会更好一些，后面再说吧。</p>
<p>大概就是这样。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2024-11.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年10月27日 周日 19:21</div>
<h2>枢纽——3000年的中国</h2>
<p>这个大部头读了好久，主线是中华民族的发展史，以及当前取得的成就，结合地缘、历史的深入解读。</p>
<p><strong>枢纽</strong>是本书强调的中心点。</p>
<p>和美国海权国家（英国也是），俄罗斯陆权国家（德国也是）不同，中国是海陆复合型国家（伊朗也是），我们不仅有绵长的海岸线、广阔的南海，还有这跟中亚、蒙古等国家接壤的国界线，是欧亚大陆（世界岛）的重要国家。跟深入内陆中亚的交流，几千年前就开始了。</p>
<p>在中国的历史上，代表草原文明、农耕文明的各民族，在不同时期作为主线，开启了属于自己的朝代。不同的王朝，都有同样的考虑，如长久的统治、稳定的社会。因此统治时，必须同时考虑草原、农耕文明。在朝代更迭的历史发展中，草原、农耕文明你争我夺，最终融合。</p>
<p>王朝最终是草原、农耕文明的枢纽，只有这样，才能稳定这两种不同的力量。</p>
<p>作为拥有绵长海岸线的国家，王朝通过海洋跟世界其他地方的联系，早就有了规模。比如马来西亚、菲律宾的华人，当年因为各种原因下南洋，还保留着华人（社会）的很多传统，说明文明的传递，其实也跨越了海洋。不过我们近代对于海洋的争斗，比较吃亏，显得海洋方面的发展，比较落后而已。</p>
<p>之前王朝在繁荣发展，人口膨胀后，都会陷入马尔萨斯陷阱，遇到天灾人祸，脆弱的经济将导致崩溃，人口减少后才能平衡下来。</p>
<p>但是膨胀的人口，却不是都坏事。比如即便清朝，跟当时的工业国——英国的贸易，一直都是顺差。</p>
<p>因为当时庞大的人口，使得即便非工业化的手工制造业，成本都很低。因此当时初步的工业化，对于王朝来说，并不划算，没法形成规模，导致社会本身没有强烈的动力去进行工业化。而王朝的框架结构，也没法在社会内部被突破改变，最终是外部世界输入的变化，压垮了王朝。</p>
<p>而作为拥有统一的法律、庞大的受教育人口、巨大内部市场的大国，在如今的工业化时代，却是优势。</p>
<p>比如我们工业化成体系后，对应现代供应链网络的迭代、进化非常快（必须拥有统一法律、巨大内部市场、相当规模人口的大国才可能），在逐渐进化的同时，东南亚的供应链也逐渐融入（一方面文化相距不远方便吸收，另一方面为了规避制裁换个牌其实很快），使得在东亚的制造业规模化成本、优化迭代成本，是全世界最经济的，不仅足以供应全世界。其规模竞争优势，也要远远优于世界其他地方的工业化成本。</p>
<p>我们每天都在进口原材料、输出最经济的工业制成品、高科技产品，在当今社会，我们就是世界经济运转的枢纽。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2024-10.html#p1">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年10月12日 周六 16:19</div>
<h2>WebSocket（2）</h2>
<p>之前版本的 cincau 是一个 MVC 模式的 HTTP server，内部认为一个业务逻辑单元（controller、或 page）可以匹配多个 URL 数据请求，一次 URL 请求将抽象为一个 request 实例给 controller 处理，controller 将 response 对应的 HTML，而 model 层则是 SVR 内部数据源的抽象。</p>
<p>所以 cincau 的 request 是一次 HTTP URL 请求的数据集合，比如请求的 method、path，header key/value 数据。</p>
<p>但后续 cincau 将支持 WebSocket，本来 WS 也是 HTTP upgrade 而来，只是 WS 是长连接，在 cincau 内部，希望继续复用已有的 MVC 模式，复用之前的 request 结构，并且，WS 和 HTTP 共用一个端口号。</p>
<p>大体上没什么问题的，在框架设计上，可以特例 HTTP 为仅有一帧的 frame，并指定专用的 frame type，而 WS 可能一次带有多帧，区分 PING、PONG、TXT、BINARY 的 frame type。</p>
<p>但作为长连接的 WS，跟 HTTP 的最大的不同，在于</p>
<ul>
<li>从 SVR 看来，CNT 有从未链接到已链接，以及从已链接到断开连接，这两种状态的变化</li>
<li>controller 需要 SVR 提供主动触发给 CNT push 数据的函数入口（目前通过定时的回调来给业务层作为触发入口）</li>
</ul>
<p>以上两点，都将复用提供 request 给 controller 的函数（参数不变，但不同状态下 request 带有不同的标记），比如使用 isPeer() 区分是 CNT 请求过来的，还是 SVR 主动触发的，以及使用 isDisconnect() 来区分 CNT 是已建立链接，还是掉线了（可能是 CNT 的 TCP 主动断开，或者 SVR PING 后一定时间内未收到 PONG 回应，SVR 主动 close 了 TCP 导致）。</p>
<p>大概是上面这样的想法，感觉应该可行。</p>
<p>然后在 <a href="https://github.com/lalawue/cincau">cincau</a> 增加了 WebSocket 的相关 demo，实现了一个简陋的聊天室。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2024-10.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年9月3日 周二 21:12</div>
<h2>更新 GitHub Page Build Process</h2>
<p>2024 年 6 月 30 日后，GitHub Pages 默认使用 GitHub Actions 拉起 Jekyll 来构建网站（需自己动手配置），若想恢复之前的分支部署，需要在发布工程根目录增加 .nojekyll 文件做标记。</p>
<p>具体可以访问这个<a href="https://github.blog/changelog/2024-07-08-pages-legacy-worker-sunset/">链接</a>。</p>
<p>我用的是分支部署的方式，所有文件都会部署为静态资源。</p>
<p>没有跟上时代步伐使用 Jekyll 的原因是，我最开始用的是 EmacsWiki 来通过 wiki 生成静态页面，后续 Emacs 不断更新，但 EmacsWikiMode 已经渐渐没人维护，我就转而使用 CommonMark 引擎的变体 cmark-gfm 来渲染 wiki，然后自己写了一个 build 管理脚本去控制页面渲染流程。</p>
<p><a href="../blog/2019-06.html#p0">《更换 Markdown Engine 为 cmark-gfm》</a>有详细的描述。</p>
<div class="category"><a href="CategoryThisSite.html">CategoryThisSite</a> / <a href="2024-09.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年8月30日 周五 22:41</div>
<h2>GTA5 大结局</h2>
<p>下载的 GTA5，大部分的时间，都是富兰克林开摩托，点开秘籍后，打爆 LSPD 的车胎后调戏，或者就直接调戏，以及各种破坏后，带着 4 星、5 星通缉逃逸（即便在地面上，还是有概率逃逸成功的）。主线的进度没怎么关注，但后面黑悟空发售了，我这边主线还没打完，如果立即切换游戏，就太可惜了，于是继续了之前的主线。</p>
<p>主线其实要认真推起来，也挺快的，最后结局选 C，三人互相帮助，免于一死。</p>
<div class="category"><a href="CategoryLife.html">CategoryLife</a> / <a href="2024-08.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年7月28日 周日 23:32</div>
<h2>1421——中国发现世界</h2>
<p>最近看了一本书<a href="https://baike.baidu.com/item/1421%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%8F%91%E7%8E%B0%E4%B8%96%E7%95%8C/10032225">《1421——中国发现世界》</a>，作者是加文·孟席斯（原英国海军潜艇编队指挥官）。</p>
<p>论证中国早在明朝郑和时，就已经进行了大规模的环球航行，发现了美洲、大洋洲、南极洲等，并出了海图。</p>
<p>哥伦布、麦哲伦、库克等就是靠着这些海图，才进行的环球航行。其舰队规模，人员配置比郑和船队小多了，如果没有这些海图，其舰队规模根本无法支撑其环球航行。</p>
<p>作者花了 14 年研究，给出了许多论据，比如船队沿路经过留下的遗物、碑文、沉船、哥伦布等人的信件等。</p>
<p>有种小时候已熟读的历史被点了刷新的感觉。</p>
<p>🐼</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2024-07.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年3月16日 周六 19:26</div>
<h2>全频段阻塞干扰</h2>
<p>感觉算是短篇小说，很早就下载啦，预计是年底前看完，这会儿终于是看完了，才花了不到一个小时。</p>
<p>因为太短，直接爆内容了，补充一下，这篇小说写于 2003 年。</p>
<p>--</p>
<p>美俄欧军事联合，进攻我国，传统战争下我国并不吃亏，但是信息战很吃亏。</p>
<p>我从书中描述，理解到的是，信息战这里并不是平等对抗，比如你有 1000 辆坦克，我有 500 辆，传统战争下对抗，我多少能耗一点你的坦克，也许是 500 辆，也许是 400 辆、300 辆，拼死之下总有消耗（其实朝鲜战争已经说明，即便是轻步兵对机械化部队，我方都是有优势的）。</p>
<p>但是信息战下不是这样，信息战之下，电磁优势的一方，不仅仅是消息传递畅通无阻，还有就是能输出强大的电磁压制，弱势一方的电磁通讯，包括指挥控制链，会被干扰导致没法使用，精确导弹没法击中目标，通讯不畅，雷达屏幕上一片白点，没有有效的指示。</p>
<p>这样高精度的制导武器不能定位目标，坦克集群作战的话，则通讯不畅，能力反而被打折了。</p>
<p>所以，我从书中理解到的电子信息战，可能造成的是，完全不对称的战争。</p>
<p>书中，我方电磁弱势，导致防守出现问题，被压缩了行动空间，人员、武器都受损，北京紧急。为了扭转这个局面，指挥部研究决定，使用全频段电磁压制，也就是要用不了电磁通讯，那大家都用不了，那传统战争下，我方反而有优势了。</p>
<p>这样就争取了某集团军防守回撤的空间，但是联军调整了战略，先清输出电磁压制的单位，因为发射电磁全频段干扰的其实是个明显的输出源，没法躲藏的，所以没太久，就被一一清理了。</p>
<p>集团军的领导有个儿子，学习成绩太好，最后研究的天体物理，一直以来，离战争都很遥远，无法理解地球上人类争夺生存空间的残酷，太优秀最后进入了研究太阳的飞行器内，独自一人离开地球，逐渐接近太阳。在国家生存受到挑战时，给出了一份解决办法：利用太阳这颗恒星，引导控制这颗恒星爆发电磁风暴，破坏地球上的电磁通讯。</p>
<p>太阳质量、能量占星系的绝大部分，这个干扰源联军是没法消除的，计算结果可以导致地球电磁受影响至一周，足够我方集团军布好防守位置，将双方拉入没有电磁能力的传统战争。</p>
<p>领导的儿子牺牲了，联军在没有电磁优势的情况下，内部有了裂痕，比如法国就退出了联军的进攻，转入防守撤退。</p>
<p>全书结束。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2024-03.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>

<div class="date">24年2月25日 周日 12:12</div>
<h2>mmap(1)</h2>
<p>自从 cincau 支持多进程的方式之后，同步数据的能力最开始是通过不同 worker 的 UDP socket 来传递的，即时性有限，大概固定几秒钟去同步一次，而且如果数据量大了也是个问题。</p>
<p>相比较下，即时性的问题才是主要的，比如其中一个 worker 接受了用户的登陆状态，用户的下个请求是另外一个 worker 来服务的，此时 cookie 的 session 信息根本还没同步过来，就成了问题。</p>
<p>当然这个问题也有粗放的解决办法，比如用 SQLite 来同步，但是这种 Key/Value 的信息也使用 SQLite 觉得还是太重了。</p>
<p>这里插播一句，之前了解过使用 mmap 来同步数据的 <a href="https://github.com/Tencent/MMKV">MMKV</a>，因为 mmap 同样可以用来多进程同步数据，因此这个库也是可以多进程同步的，感觉这个库可以解决 95% 以上的同步问题，其他的例外情况，我下面会说。</p>
<p>在展开其他方案之前，我得检讨一下，一开始走了很多的弯路，虽然了解到需要使用一些多进程同步手段，比如最开始的 socket，比如可以使用 Linux 消息队列，以及 mmap，但是我把这个问题想得简单了，而且一开始我也没想起 MMKV。</p>
<p>比如我一开始就选择了 mmap，想做一个 mmap 的有序字典，我手头有 MIT LICENSE 的 AVL tree 代码，相比之下 MMKV 这种 bitcask 结构的数据库，是无序的，除非你 dump 出来所有的 key 再排序，否则你无法快速拿到按照 Key 排序的第一个节点，而 AVL tree 对 Key 排序的方案就可以。</p>
<p>可是已有的 AVL Tree 的方案，其对节点的引用是指针的，虽然 mmap 只管映射内存区域，但是不同的进程，其映射的内存区域很可能不一样，比如我使用的 LuaJIT，除了我自己主动调用的 mmap，其他不知道什么原因，也有不少的 mmap 调用。导致如果使用 AVL tree 的方案，除非是能保证每一个进程 mmap 过来给 AVL tree 使用的内存块，采用同样的起始地址，否则后续的指针计算，指向的节点地址就有问题。</p>
<p>虽然理论上，我可以将进程空间的一大段都交给这个 AVL tree 共享内存的方案，但是实际做起来其实也不方便，而且 mmap 这个系统调用其实很频繁，用 strace 就可以看到，其他的一些文章也有介绍。</p>
<p>所以，不得不将 AVL tree 的指针引用，改成 int32_t 的间接引用，这里的 int32_t 分成了高 16bit 和低 16bit，其中的高 16bit 用于 index 内存区块，低 16bit 用于 index 每个区块内的位置，byte offset。</p>
<p>之所以这么做，是因为内存块是动态申请的，不会一下就申请完所使用的内存，而是根据使用量逐步申请，虽说是共享内存，也总得使用实际内存空间的嘛。</p>
<p>另外这个 AVL tree 的方案相比 MMKV，其实有很大的限制，因为考虑到不想做 bitcask 那样的回收方案（简单点做），因此设置了限定最大的 Key/Value 长度，这个是调用库在初始化的时候就得进行设置的。</p>
<p>比如 Key/Value 的最大长度是 64 字节，其中 Key 是一个 timestamp 占 32 字节，后续的 Value 是一个 MD5 的 hash 占 32 字节，这里还可以插播一句，可以将这个 Value 作为 MMKV 的 Key，这样就实现了 MMKV Key 的有序，回应了最开始说的 95% 的应用场景。不过这里也得提一下，MMKV 还可以设置每个 Key 的过期时间，所以这个 95% 的应用场景，实际上还可以扩大不少。</p>
<p>回到刚刚的 AVL Tree，所有需要同步的数据都存放到 mmap 的内存区块中，每个进程都有对 AVL Tree 的引用，以及自己保留一份已经打开的内存区块列表，当别的进程因为塞入更多的数据申请了新的内存区块，其他进程在进入库调用的时候，检查到这个场景，将新的内存区块也 mmap 到自己的进程空间上。</p>
<p>因为每条数据是固定的长度（最大 Key/Value 长度），所以 AVL Tree 的 index 间接指针会忽略掉不同进程内存区块的起始地址不一致的情况，只关注内存区块的序号，以及每条数据对应内存区块的偏移字节，当这个内存区块已经映射到进程空间上后，对 index 的数据的读写就没有障碍了。</p>
<p>在实际使用中，当内存空间不足时，申请内存区区块序号（2^16个），映射内部的节点地址偏移，两者揉进每个节点的唯一 index，当删除节点时，节点可以回收而不需要整理内存区块，比如将该节点的 index 保存到未使用空间列表节点的 right 指针（间接指针）中。</p>
<p>上面说完了 mmap AVL Tree 的使用场景、面临的问题，提出的解决方案，和该方案的限制，下面列出来了一些实际跑通该场景的有趣细节：</p>
<ul>
<li>AVL Tree 需要对比 Key 才能排序然后旋转，但是这个比较函数的运行空间是在不同的进程地址空间，因此每个进程在实际进行查找、插入、删除时，得使用自己进程空间的比较函数来执行，如果比较函数的函数指针，用的是其他进程的，那就有问题了（父子进程不在此讨论范围）</li>
<li>mmap 有些参数需要注意，除了多进程共享一定会用到的 MAP_SHARED，还得使用 MAP_POPULATE，否则后续其他进程将内存区块加载进来后，会遇到问题，这个参数是告诉 mmap，为了避免后续访问地址的 page fault，得将此文件涉及到的内存地址，先全都映射上来</li>
<li>mmap 只涉及到共享的内存区块，为了保证数据的一致性，还得在访问时加锁，需要用到 pthread_mutexattr_setpshared 的 PTHREAD_PROCESS_SHARED，除此外，当某个进程 crash 掉而没有清理 pthread 数据时（共享的内存区块中），其他进程在锁的处理过程中，需要 pthread_mutex_consistent，这个是在初始化 mutex 时通过 pthread_mutexattr_setrobust 的 PTHREAD_MUTEX_ROBUST 参数保证的</li>
</ul>
<p>细节太多了，当然相比较 SQLITE，上述两套方案的效率会高很多。</p>
<p>MMKV 已经很成熟，多平台都能支持，AVL Tree 是我当初小看了 mmap 导致的，而且有先天的短板，虽然说提供了有序 Key 的能力，但这个是在约束了最大 Key、Value（每条数据都是这个最大长度）来达到的，因为可以避免替换 mmap 共享的内存区块。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2024-02.html#p0">Permalink</a> / <a href="https://github.com/lalawue/homepage/discussions/categories/blog" target="_blank">Discussion</a></div>
<!-- Page published by cmark-gfm ends here -->
  <div id="foot">2004-<script>var d = new
	Date();document.write(d.getFullYear())</script> &copy;
	Sucha. Powered by MarkdownProjectCompositor.
  </div>
  </div><!-- text -->
  <div id="sidebar">
  </div><!-- sidebar -->
  <script src="../js/prism.min.js" async="async"></script>
  <script src="../js/blog_sidebar.js"></script>
  </div> <!-- body -->
</body>
</html>