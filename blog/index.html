<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>Sucha's Blog - Welcome</title>
    <meta name="generator" content="MarkdownProjectCompositor.lua" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="Sucha" />
    <meta name="keywords" content="suchang, programming, GNU, Linux, Emacs, Lua" />
    <meta name="description" content="Sucha's blog" />
    <link rev="made" href="mailto:suchaaa@gmail.com" />
    <link rel="shortcut icon" href="../images/ico.png" />
    <link rel="stylesheet" type="text/css" href="../styles/blog.css" />
    <link rel="stylesheet" type="text/css" href="../styles/prism.min.css" />
  </head>
  <body>
    <div id="body">
      <div id="text">
	   <!-- Page published by cmark-gfm begins here --><h1>Sucha's Blog ~ Welcome</h1><div class="date">22年2月10日 周二 00:56</div>
<h2>LuaRocks with LuaJIT (2)</h2>
<p>之前我还提到<a href="../blog/2020-07.html#p3">使用了 torch 的 LuaRock 方案</a>，但实际上不晓得 LuaRocks 在哪个版本起（至少在 3.7），编译的时候指定 Lua 解释器，就能直接支持，我其实已经用上很长时间了。</p>
<p>说实话，比较期待 LuaRocks 的方面是，直接根据依赖的 rocks，能够输出 single executable，虽然按照目前 LuaRocks 的 spec 构建描述，应该是很难的。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2022-02.html#p0">Permalink</a></div>

<div class="date">22年1月27日 周四 14:42</div>
<h2>MoocHelper</h2>
<p><a href="https://github.com/lalawue/mooncake">MoonCake</a> 终于有了支持 LSP 的 VSCode 插件
<a href="https://github.com/lalawue/MoocHelper">MoocHelper</a>，修改自 <a href="https://github.com/Tencent/LuaHelper">LuaHelper</a>，
一个基于 go 的 Lua LSP 方案。</p>
<p>话说 12 月底到 1 月中旬大部分的时间都在补充完善这个插件，基本功能两周之内的业余时间就搞定了。不得不说 go 确实比较简单，另外 LuaHelper 的代码结构也可圈可点，很好懂。</p>
<p>基本功能完成后，就开始了边用边改的流程，就这样又过了两周多，感觉配置好后，在 Mac 上的基本使用没啥问题了。</p>
<p>对比一下原版的功能，基本的代码补全，跳转，提示都是有的，只是缺少 debug 能力，因为 moocscript 是先翻译成 Lua 再交给 Lua 解释器的。另外，配置方面，修改了 luahelper.json 的读取路径，修改到了 .vscode/ 目录下。增加了配置项 ProjectLuaPath 以及 ProjectLuaCPath，对应工程使用的 LUA_PATH 和 LUA_CPATH 携带的路径列表。</p>
<p>增加了这两个配置后，浏览代码期间的环境变量跟运行时候就几乎是一样的了。</p>
<p>说到 Lua LSP 的方案选择，之前考虑过 <a href="https://github.com/sumneko/lua-language-server">sumneko/lua-language-server</a>，虽然我是 C/C++ 以及 Lua 都了解，但初步评估后，发现门槛有点高，不知道如何入手修改，以及 debug，想哭😭。</p>
<p>相比之下，基于 Go 的 LuaHelper，就太好 debug 了。只要按照 README 描述，在插件配置里面将选项 <code>connect lsp server way</code> 修改为 socket（默认是 cmd），而在另外一边的 luahelper-lsp 目录，按下 F5 就开启了调试模式，断点什么都特别方便。就算像我这样 go 基础非常浅的，也很快弄懂了如何 debug，几遍下来，程序的结构就很清楚了。</p>
<p>相比之下，lua-server 是 Lua + C++ 的方案，估计调试没那么容易，当然 go 的效率较高又是另外一个点了。</p>
<p>除此之外，我还看了一下相关的代码，知道其最终输出是 AST，后续的语法分析，提示、跳转什么都是依赖这个 AST 工作的，大概读懂这个 AST 结构后，我就比较放心了。moocscript 虽然语法不一样，但其最终会编译到 Lua，会沿用一样的 AST 结构，不会遗漏语言表达的任何细节。</p>
<p>一开始我想用 lua-server 的，但几遍下来，看不懂 parser 部分，没能抓住最后输出 AST 的逻辑，少了这个核心关键点，就只能放弃了。</p>
<p>也是基于上面输出同样 Lua AST 的原因，除了 debug 功能外，其他的功能，moocscript 和 lua 几乎是一样的，只是有一些限制。</p>
<p>这些限制是因为 Lua 和 MoonCake 在 token 阶段，共享了 token 这些关键字，moocscript 的关键字比 Lua 多了不少，这些关键字在 MoocHelper 里面的 Lua 文件也会被提示不能使用而报错，虽然 lua 解释器是能正常运行这些脚本的，这也算缺点之一吧。</p>
<p>对了，因为 AST 共通，所以 MoocHelper 也能解析 Lua 代码，工程里面不同文件，混用 moocscript 和 lua 都是没有问题的。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2022-01.html#p0">Permalink</a></div>

<div class="date">21年12月30日 周四 23:09</div>
<h2>鬼吹灯读后感</h2>
<p>不记得是月初还是上个月就看完了《鬼吹灯》，当然是全本，在微信阅读上看的，送了很多书币，断断续续就看完了。</p>
<p>共 232 章节，记得是中间那段还比较好看，前面略显沉闷，后面呢，感觉故事跟前面差不多，没有太多新意。</p>
<p>我自己对这个小说分类是穿越、惊悚类的探险小说，主要的场景是中国西北部、新疆、四川藏区的地域风情。故事里经常动不动就穿越了几千年，温存的场景少，打打杀杀、偷鸡摸狗的场景多，当然主角总是劫富济贫、危难中救人。</p>
<p>这个题材拍电影感觉会很好吧，鬼洞、鬼眼，以及蓝色的萤火虫鬼火，听到觉得挺吓人的了。</p>
<p>荒漠、戈壁、雪山下面探险，跟大粽子激斗，与狼王周旋，跟千年前的蛊术斗智斗勇，手中握着分金定穴的秘术，总是绝处逢生，但又被之前精绝古城的鬼眼、鬼洞病债，不得不到处寻方求生。</p>
<p>故事就是这样串联起来的吧。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2021-12.html#p0">Permalink</a></div>

<div class="date">21年11月30日 周二 21:24</div>
<h2>div 内容过长的显示</h2>
<p>js 入门的简单问题，我还是 baidu 了一下，花了一些时间，解决办法需要 CSS，设置 height 或者 max-height，然后设置 overflow 属性，如下</p>
<pre><code class="language-css">.code {
    max-height: 1024px;
    overflow: auto;
}
</code></pre>
<p>实际上，我是通过 js 来设置 docuementId 属性的，因为监听了 resize 事件，我觉得加了下面的函数更完善，可以根据可见区域到校重新 layout，如下：</p>
<pre><code class="language-js">window.addEventListener('resize', function(){
    if (document.body.clientWidth &lt; 1024) {
        document.getElementById('tag').removeAttribute('style');
    } else {
        document.getElementById('tag').setAttribute('style', 'max-height: ' + (document.body.clientHeight) + 'px;overflow:auto;');
    }
})
setTimeout(() =&gt; {
    var event = new Event('resize');
    window.dispatchEvent(event);
}, 1);
</code></pre>
<p>用了 setTimeout 来激活 resize，所以只需要设置一个 resize 监听就好，上面 js 意思是如果可见宽度 &lt; 1024，其实我是将其当成 phone 显示的，就不需要滚动条了。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-11.html#p4">Permalink</a></div>

<div class="date">21年11月25日 周四 22:51</div>
<h2>基于 luarocks/luastatic 的二进制打包工具</h2>
<p><a href="https://github.com/ers35/luastatic">luastatic</a> 可以打无依赖的二进制包，但是官方的版本有一些限制，比如在命令行里面，lua 源文件之只能是基于当前打包目录的相对路径。</p>
<p>而实际上，由于 lua 的 LUA_PATH、LUA_CPATH 以及 package.path 和 package.cpath 太自由，可以定制很多种搜索优先级，以及目录相对关系，打包目录下的相对路径，就不能反映源码上面的 require 路径逻辑了。</p>
<p>于是我基于上面的 luastatic，做了一点改进，可以输入相对路径，代码在 <a href="https://github.com/lalawue/luastatic">lalawue/luastatic</a>。</p>
<p>举个例子，一方面，我重度使用 luarocks 安装的库，比如 cincau，默认目录可以是 /usr/local/share/lua/5.1/cincau，而另外自己写的源码，都在 app 目录下，然后设置了如下的 LUA_PATH：</p>
<pre><code class="language-shell">$ export LUA_PATH=&quot;/usr/local/share/lua/5.1/cincau/?.lua;./app/?.lua&quot;
</code></pre>
<p>这样在 require 的时候，省却了很多相对路径。如果使用官方的 luastatic 打包，就得建立相对目录，然后作为命令行参数输入给 luastatic，用我修改后的 luastatic，只需要先设置 shell 变量：</p>
<pre><code class="language-shell">$ export LUASTATIC_SOURCE_PATH=&quot;/usr/local/share/lua/5.1/cincau/;app/;&quot;
</code></pre>
<p>注意目录最后的 '/' 和 ';'，如果输入的 lua 源文件检测到相应的路径前缀，会将这个前缀去掉，这样就实现了 LUA_PATH 和 package.path 的功能，运行时的路径搜索和打包时候的路径一致了，不需要构建相对目录。</p>
<p>另外需要注意的是，虽然 luastatic 支持生成无依赖的 binary，但那只是对应官方的 lua，luajit 依赖的 .so 库还是需要动态加载的，比如很多的 ffi.load 依赖的是系统的 dlopen。这个我看了一些文章，大佬们根据安全原则，系统的接口都不支持从内存中加载一个动态库，虽然某些平台上通过 mmap 是可以做到的，但是这个总感觉不大好。</p>
<p>那如果是基于 luajit，lua 源文件是打到 binary 里面了，但是依赖的 so 库，是在运行前，通过 export LD_LIBRARY_PATH 或者 DYLD_LIBRARY_PATH 来设置 so 搜索路径，做成外部库加载的。</p>
<p>通过这样的方式做成的 binary 发布包，可以在对应平台上不依赖 luarocks 就可以运行，安全性也好一些，发布更新都很方便。</p>
<hr />
<p>话说昨天看了一下 <a href="https://programming-language-benchmarks.vercel.app/">Programming Language and compiler Benchmarks</a> 里面 go vs java，go vs javascript 以及 go vs luajit，不得不说 go 性能确实好，速度跟 java 一样，但是内存消耗少了不知多少。</p>
<p>luajit 平均速度是 go 的一半，内存消耗多了一些，javascript 速度跟 luajit 类似，但内存消耗多很多。</p>
<p>如果是从头学起的话，我觉得 go 是要比 java 简单很多的，工程属性方面，go 更是标杆，如果算上多线程 goroutine 的话，毫无疑问，go 是首选。多线程多难搞呀，所以小公司很可能都慢慢转向 go 了，反正我是觉得真的香呀，现在都有点后悔搞 luajit 了，因为速度是赶不上 go 的，基础工具又差这么多。</p>
<p>上面的所谓打二进制包，就是补充了一部分基础工具的缺失，即便不说标杆 go，人家 deno 也是可以打成二进制包的。</p>
<p>luajit 不多的优点，一方面是不需要编译，虽然 go 编译很快，但是不需要编译连这个部分都省略了；另外就是 luajit 语法几乎是固定了，不大担心后续会有比较大的变动，唯一担心的额是 Mike Pall 是 luajit 几乎唯一的维护者，社区太小了，这个软件太高深，往后一些平台的支持以及升级估计够呛，更新也慢。</p>
<p>lua 语言的的优点在 web 开发上面不大体现得出来，相比之下，比如虚拟机很小，这样轻量的虚拟环境、沙箱，可以造就诸如国内有名的 <a href="https://github.com/cloudwu/skynet/">skynet</a>。</p>
<p>lua 语法更简单，类型都可以少关心，但并不意味说这个语言抽象能力不够，或者扩展不行，如果 metatable 抽象得好，可能性太多，OO 小菜一碟，比如我之前基于 lua 构建的 mooncake；所以，也没有泛型渴望症；但是因为缺乏类型系统，那么测试系统得自己保证才放心。话说，也是因为语言自由，lua 很多库的源码，相对 go 源码来说，可太难懂了。</p>
<p>最近还看了 WASM，感觉也很香，go 自从 1.11 后，支持输出 WASM，但 WASM 这个技术还比较早期，W3C 上面到了提案 2 的阶段，还没有多线程这样的标准。从上面效率对比，跟 go 是一个级别。</p>
<p>这次 post 先到这里吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-11.html#p3">Permalink</a></div>

<div class="date">21年11月17日 周三 21:52</div>
<h2>诛仙读后感</h2>
<p>以前没读过仙侠系列，算是第一次读。</p>
<p>前段意境真的很美，特别是上了青云山拜师之后，掌管大厨的这一段，跟师姐砍竹子，带领一猴一狗每天在这仙山里面慢慢悠悠升级，就觉得这感觉很好。</p>
<p>而且内线是有内功见长，又少不了武侠里面的捡到了绝世大宝贝，比如土到不能更土的烧火棍，以及后期那些救人于水火，法力无边的宝贝，更是让人羡慕神往。</p>
<p>起伏线的大起大落也很经典，以及一直不受师傅待见，但最后唯一一个给师傅长脸的徒弟，又比如被掌门下杀心的一段而成为鬼厉，从此杀人无数。</p>
<p>支线里面厉害的有万剑一，以及仙人指路，野狗跟仙人指路能走到一块，这个组合在人心里面又重了，这条线里面的仙人指路水平太高，应该是作者的用来补充剧情的旁白。</p>
<p>但是也有遗憾的支线，比较不能理解的是陆雪琪，一直走不到明线，但是暗线又这么强烈，难受。</p>
<p>前面写得太好了，觉得跟兽人大战之后，跟魔教对决的这一段，马马虎虎，没啥感觉。</p>
<p>总体可以打 7.5 ~ 8 分了。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2021-11.html#p2">Permalink</a></div>

<div class="date">21年11月11日 周四 00:33</div>
<h2>Mithril 使用心得（1）</h2>
<p>这个网站已经诞生 10 多年，但其是静态页面，基于 XHTML 结构，而不是最新的 HTML5，站长本人是专业 APP 开发，
H5/Web 开发比较业余，对 <a href="https://mithril.js.org/">Mithril</a> 的使用感觉还不够深入，但也算趟了一些坑，
可以作为心得说一下的。</p>
<p>说一下为何不使用 React、Vue 或者 Preact，以及 Angular 等等其他框架，没什么原因，因为其实入手之前看了非常多的入门对比文章，
在对比的过程中总是要上手的嘛，因为看到 Mithril 吹自己简单，其网站入门教程的介绍也是非常到位的（React 没能一下学会，
但是 Mithril 可以），加上不需要 nodejs 这样的依赖，不需要 build，学习的曲线感觉很平缓。</p>
<p>话说我之前是一个连 SPA（Single Page Application）都不懂的人，通过 Mithril 的教程，学会了基础的 component，
route、以及 XHR，基本上一个单页面就可以搞定了。</p>
<p>再说还有 <a href="https://stackblitz.com/">stackblitz</a> 这样的平台，入门是很方便的。因为是个无需 build 的方案，
简单的 HTML5 + rel 标签带入 Mithril 就可以开始工作了。</p>
<p>js 我也只懂皮毛，很多东西都得百度，没关系，出来的程序能用就行。最后做了 2 个 SPA 页面，一个是 wiki，一个是 note 便签。</p>
<p>wiki 的相对简单一些，大概 2 - 3 天才搞定，学习了 route，但是内部的很多状态我是通过一个全局状态变量来控制的。
便签这个页面没有用到路由，纯内部状态跳转刷新，两个都没有用到 browser 的 history，浏览器的返回按钮会退回上个 URL。</p>
<p>Mithirl 的 bind 或者 route，都可以仅指定页面的一个部分，一个 element 来刷新，内部是根据 vnode 的变化来判断是否更新的，
这个 vnode 变化感觉有点悬乎，比如我在创建一些子节点的时候，attribute 是有变化的，但是 Mithril 感觉不到这个变化，
所以我不得不在外层做更明显的 vnode 变化，比如增加一个用不到的 span 标签这样，来确保重新输出 HTML 节点。</p>
<p>Mithril 限定 60hz 刷新确实也不错，但是遇到一些极端情况，比如自己本地测试的时候，网络返回就挺快的，当我在用内部变量控制
vnode 输出的不同时，因为间隔过短，虽然变量有切换状态，但 Mithril 间隔读取到的其实都是同一个状态下的 vnode，
而忽略了中间这个变量状态下 vnode 的输出，最后导致认为没有变化，不需要刷新，出了问题，如下：</p>
<pre><code class="language-source">// 如下的 A、B 表示变量值，后面数字表示 vnode 结构为 A 但内容不同，这里需要保证 A1 -&gt; B 间隔 1/60 秒
A1 -&gt; B -&gt; A2
</code></pre>
<p>所以有时候，需要将一些操作延时到 60hz 单次刷新之外才行，让 Mithril 检测到 vnode 变化。</p>
<p>Mithril 教程用的是古老的创建 vnode 的函数调用方案，但其实可以配合 preact 的 <a href="https://github.com/developit/htm">htm</a>，
我觉得使用方式上要比教程里面的简单很多，比如教程是下面这样创建 vnode 的：</p>
<pre><code class="language-js">// 下面 title_str 是变量
// &lt;h1 class=&quot;title&quot;&gt;My first app&lt;/h1&gt;
const title_str = 'title';
m(&quot;h1&quot;, {class: title_str}, &quot;My first app&quot;)
</code></pre>
<p>如果用了 <a href="https://github.com/developit/htm">htm</a>，可以像下面这样：</p>
<pre><code class="language-js">// 先绑定，最后也是通过 m 函数来输出 vnode 的
const html = htm.bind(m);
const title_str = 'title';
html`&lt;h1 class=&quot;${title_str}&quot;&gt;My first app&lt;/h1&gt;`
</code></pre>
<p>明显是使用了 htm 的代码更容易定位问题。</p>
<p>因为追求短平快，单个 js 文件就完成了 wiki 或者 note 便签这样的功能，所以 Mithril 结构化方面我是没有发言权了，教程上面
呼吁结构化组件，分解功能模块我是一点都没用上。</p>
<p>先这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-11.html#p1">Permalink</a></div>

<div class="date">21年11月07日 周日 11:46</div>
<h2>stunnel 的 SNI 配置</h2>
<p>因为是很小的网站，资源也有限，感觉没必要用上 openresty 这个大件。</p>
<p>先贴配置：</p>
<pre><code class="language-ini">debug=info
output=/path/to/access.log
pid=/path/to/process.pid
client=no

[https]
accept = 443
connect = 127.0.0.1:port1
cert = /path/to/default.cer
key = /path/to/default.key

[site1]
connect = 127.0.0.1:port1
sni = https:site1.domain
cert = /path/to/site1.cer
key = /path/to/site1.key

[site2]
connect = 127.0.0.1:port2
sni = https:*.site2.domain
cert = /path/to/site2.cer
key = /path/to/site2.key
</code></pre>
<p>说一下上面的配置。</p>
<p>这是类似 INI 方式的配置文件，首先定义是 server 端的配置，设置 access.log 和 process.pid 文件的位置。</p>
<p>之后设置默认协议，比如叫做 https，监听 443 端口，并设置连接地址，使用默认的 cert 和 key 做验证，这里其实是可以跟下面的 site1 或者 site2 用同样的 cert 和 key 配置。</p>
<p>之后分别设置不同网站对应的处理地址，比如 site1，连接的是 port1，注意 sni 字段配置，第一个是协议，就是上面描述过的 https，而不是 HTTPS，之后是需要处理的 domain，这里只处理二级域名，没有通配字，最后加入网站申请到的 cert 和 key。</p>
<p>site2 的 sni 用了通配字，所有 site2.domain 的二级、三级域名都可通过验证处理。</p>
<div class="category"><a href="CategoryLinux.html">CategoryLinux</a> / <a href="2021-11.html#p0">Permalink</a></div>

<div class="date">21年10月02日 周一 22:48</div>
<h2>独立 SideBar</h2>
<p>将 site 和 blog 的边栏 sidebar 独立到各自不同的 js 文件上去了，比如</p>
<ul>
<li><a href="../js/site_sidebar.js">site_sidebar.js</a></li>
<li><a href="../js/blog_sidebar.js">blog_sidebar.js</a></li>
</ul>
<p>修改后的好处，是需要更新 archive links 时，也只需要更新对应的 sidebar js，而不需要更新每个月份输出的 HTML 了。而之前作为 static site generator，是独立输出到每个月份 HTML 上面去的。</p>
<p>内容跟 sidebar 分离后，完全可以没有什么顾忌的更新 sidebar 了，当然其实我也几乎不会更新 sidebar，感觉没啥必要，🤗</p>
<div class="category"><a href="CategoryThisSite.html">CategoryThisSite</a> / <a href="2021-10.html#p0">Permalink</a></div>

<div class="date">21年9月30日 周四 23:59</div>
<h2>9 月份干嘛了</h2>
<p>其实 9 月份做了蛮多的事情，公司那边慢慢忙起来了，在公司里面做了一个数据库抽象模块，其实就是一个抽象的 DAO（Data Access Object），使用的是 GRDB，起因是使用的 Realm 版本太旧了，启动后未知原因的 crash 飙升，堆栈上看是启动时候 Realm 在初始化 ObjC 这一层某个 sub class 时候就挂了，都还没有任何 DB 的操作逻辑呢，其实就是 DidFinishLaunch 都没走完。</p>
<p>因为工程早就都是 Swift 了，不想呆在 ObjC 里面，太多的 swizzle 黑魔法，对工程代码质量要求太高，小公司很难保证。因为 DB 操作大部分都仅仅是序列化逻辑，上没有复杂的 join、foreign key 操作，所以只是简单封装了一下 GRDB，抽象独立为 Pod 库，不污染工程代码就好。基于这个前提，抽象了 fetch、push、watch 接口，Pod 内部建立内存模型跟 DB 模型的对应，其实就是表操作。可以通过上述的几个接口，接入不同的带 param 的 enum 参数，就可以完成功能。有了这一层抽象，后续即便 GRDB 因为各种原因不能使用，我们不需要修改业务代码，只需要在 Pod 这一层做内存到外存的转换就好。</p>
<p>另外还抽象了一个指定 key 的 JSONObject 模型，里面可以放入各种深度、层次的 JSON 数据，insert、update、delete、watch 时候，都关联到 key 上就好，对于一些需要序列化的数据，又不想用 UserDefault 来做，就可以使用这个 JSONObject 来存入 GRDB，实际上是作为 blob 数据存储进去的，目前只支持一个 key，一般都是什么什么 id 之类的，这也是目前能够支持绝大多数业务的序列化功能。</p>
<p>另外学写了一下 SPA（Single Page Application），Web 发展迭代速度要比移动 App 快多了，可选的很多，React、Vue、Preact 都有，我稍微摸索了一下 React，觉得有点拎不动，然后 Vue、Preact 也一样，再说这些东西依赖很重，nodejs 几乎是必须的，build 过程少不了，最后我选了 Mithril。之前有听说过，然后在<a href="http://www.ruanyifeng.com/blog/">阮一峰</a>那边又被推了一下。教程相对简单，而且是只支持 browser，不需要 build 过程，我学习了两三天，做了一个 Wiki 管理工具，用的 Markdown IDE 是 <a href="https://simplemde.com/">SimpleMDE Markdown Editor</a>。</p>
<p>选择 Mithril 的原因除了它自己吹嘘的之外，还有其他的考量，比如可以利用上之前的 HTTP Server <a href="https://github.com/lalawue/cincau">Cincau</a>。这个新作的 Wiki 管理工具，最后就作为了 Cincau 支持的一个 SPA Demo 页面。其实 SPA 对后端没什么依赖，后端主要是模版 SSR（Server Side Render）。当然有了这个 Wiki 工具，我就可以将之前另外一个小站点的 Wiki 移过来，直接在搭建在 Cincau 上面，话说之前的 Wiki 是 <a href="https://www.dokuwiki.org/">doku</a> + php + nginx 来搭建的，改成 Luajit + Cincau 后，资源依赖少了很多，不过相对功能也少了很多，这些坑只好自己趟了，对于我这个职业 App 开发者来说，也是一个学习的过程。</p>
<p>上面说到 SSR，因为不大喜欢之前搭配的 <a href="https://github.com/leafo/etlua">etlua</a>，于是自己做了 <a href="../blog/2021-08.html#p0">lua-html-tags</a>，这个之前 8 月份的时候提过了。</p>
<p>话说之前 doku 除了基本的 Wiki 功能（用得比较早，当时还不知道 CommonMark 或者 GFM 的语法），还有 revision，以及 show diff 的功能。我觉得这个功能挺好的，对于刚用 Mithril 做的 Wiki 工具来说，可以有效避免某些错误操作导致的 clear 逻辑（当然这从来就没发生过），对心理造成的压力，毕竟有 revision，我可以随时恢复到任何一个版本。</p>
<p>增量保存用的工具是 <a href="https://github.com/mendsley/bsdiff">bsdiff</a>，其实用系统里面自带的 GNU 的 diffutils 或者 patch 也是可以的，只是在 server 这一层，需要调用太多次 shell 脚本完成相应的功能，觉得不大好。于是将这两个工具做成了 Lua 库 <a href="https://github.com/lalawue/lua-bsdiff">lua-bsdiff</a>，并 apply 了两个觉得挺不错的 patch。</p>
<p>不过上面提到的 Wiki 支持 revision 功能，在 cincau 的 demo 上面是没有的，目前没打算开源，🙂</p>
<p>9 月份忘记写 blog 了，10 月初初回顾了一下，后面有时间再详细铺开，先这样吧，🤗</p>
<div class="category"><a href="CategoryLife.html">CategoryLife</a> / <a href="2021-09.html#p0">Permalink</a></div>

<div class="date">21年8月31日 周二 22:37</div>
<h2>lua-html-tags</h2>
<p>上周才知道 <a href="https://stackblitz.com/">StackBlitz</a> 的在线代码编辑工具，是一个 React JS 编辑器，包括了自动导入的包管理等功能，React 这边随便编辑修改页面添加变量，右侧的页面瞬间刷新，看着这样的前端开发实在太香了。相比之下，虽然 Swift 开发还有类型信息，但是为了上真机跑起来，还得编译链接，老费劲了。</p>
<p>其中 React 将页面和逻辑都放到一起的做法，感觉挺好的。</p>
<p>因为之前做了一个 <a href="https://github.com/lalawue/cincau">Cincau</a> web 框架，用了 <a href="https://github.com/leafo/etlua">etlua</a> 做模版渲染引擎，发现其实还是要写很多的 HTML，而且之前的做法是将模版和实际的逻辑页面分开、model 分开，为了搭建一个页面，心智经常要顾及太多文件，再加上我搭建的多页面跳转的 demo，router 加上各个页面、model、template，真的让人头大。</p>
<p>但为此将模版文件放到业务逻辑里面，又感觉太啰嗦了。</p>
<p>就想找一个将 HTML tag 和 Lua 结合起来的描述语言，其实看过一些短小的，后来看到较大的是这个 <a href="https://github.com/bungle/lua-resty-tags">lua-resty-tags</a>，但是这个使用的时候需要建立 tags 描述的，非开箱即用感觉不够专业呀。</p>
<p>我描述一下自己的需求吧</p>
<ul>
<li>基本的 HTML tags</li>
<li>可以自定义 tags</li>
<li>支持 attributes 等</li>
<li>不影响当前 _ENV 和 fenv</li>
<li>可以 include 文件</li>
</ul>
<p>最终是自己摸索着建立了一个 <a href="https://github.com/lalawue/lua-html-tags">lua-html-tags</a>，这些 tags 实际上都是 Lua function，因为 Lua 语法的关系，function 可以不加括号接受一个 string 和 table 作为参数，让之前相对简洁的 HTML 描述得以实现。</p>
<p>简单描述一下实现逻辑：</p>
<ul>
<li>因为需要包裹在特定的 _ENV 和 fenv，所以页面描述是用 function 包裹返回的</li>
<li>返回的最外层是一个 table</li>
<li>里面的每一项如果不是 function 或者 table，就转成 string 输出</li>
<li>如果是 table 就遍历取值<sup><a href="#fn1">特例</a></sup></li>
<li>遇到类似 HTML tags 这样的 function 就调用取返回值</li>
</ul>
<p>可以看到，从最外层的 table 开始遍历后，处理方式都是一致的递归描述，举个简单的例子</p>
<pre><code class="language-lua">local Tags = require(&quot;html-tags&quot;)

local function pageSpec()
    return {
        html {
            head {
                meta { name=&quot;generator&quot;, content=&quot;MarkdownProjectCompositor.lua&quot; },
                title &quot;Example&quot;
            },
            body {
                div {
                    { id=&quot;body&quot; },
                    p {
                        &quot;content 1, &quot;,
                        &quot;content 2&quot;
                    }
                }
            }
        }
    }
end

print(Tags.render(pageSpec, {}))
</code></pre>
<p>最终会生成这样的 HTML（经过了部分换行编辑）</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;meta name=&quot;generator&quot; content=&quot;MarkdownProjectCompositor.lua&quot; /&gt;
    &lt;title&gt;Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;body&quot;&gt;
        &lt;p&gt;content 1, content 2&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>由于这个页面描述就是 Lua，所以加入相关的变量、函数计算是很简单的事情，而且因为限定了 _ENV 和 fenv，所以 HTML tags 和自定义的 tags 对相关函数外的 Lua 的运行环境都没有影响。</p>
<p>感觉还可以说一下 _ENV 和 setfenv 等相关的事情。实践下来，是觉得 getfenv、setfenv 的灵活性很高，_ENV 比较受限，但也许从语言设计者的角度来说，_ENV 更安全一些吧。</p>
<p>先说一下这个 include tag 的作用，就是引入一个 Lua 文件描述的子页面，最终是输出一串字符串到这个 tag 的位置。使用场景时，比如我做了很多页面，但是想用同样的 HTML head 描述，当我改变 head 的描述是时，希望所有页面都能同样做更改，那么我将这个 head 文件拎出来单独描述就好。</p>
<p>比如将上面的例子命名为 head_tpl.lua，那么引入的时候可以是这样：</p>
<pre><code class="language-lua">local function pageSpec()
    return {
        html {
            include &quot;/path/to/head_tpl.lua&quot;,
            body {
                ...
            }
        }
    }
end
</code></pre>
<p>当这个文件被 loadfile 进入 Lua，就成了一个 function，之前我说过给 pageSpec 设定了 fenv，而 include 是早已经建立好的函数，有自己的 fenv，这时候 include 进来的 head_tpl 函数，如果我不设置 fenv，直接调用获取结果的话，用的是 include 的 fenv。</p>
<p>在 5.2 时，如果我不事先记录 pageSpec 的 fenv，从 pageSpec 调用了 include 函数，在 include 函数里，我无法获取到 pageSpec 函数的 fenv，即便你知道堆栈上的前一个函数有我需要的 fenv，但就是拿不到。</p>
<p>在 5.1 的时候就很简单了，getfenv(2) 可以取到堆栈上前一个函数的 fenv，然后 setfenv 就行，方便极了。</p>
<p><sup>[<a id="fn1">特例</a>]</sup>：HTML tags function 在实现时，如果紧接着的 table 参数里面的第一项还是 table，是特别作为属性 key / value 用 pairs 函数遍历的，比如之前例子里面的 div id=&quot;class&quot;</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-08.html#p0">Permalink</a></div>
<!-- Page published by cmark-gfm ends here -->
  <div id="foot">2004-<script type="text/javascript">var d = new
	Date();document.write(d.getFullYear())</script> &copy;
	Sucha. Powered by MarkdownProjectCompositor.
  </div>
  </div><!-- text -->
  <div id="sidebar">
  </div><!-- sidebar -->
  <script type="text/javascript" src="../js/blog_sidebar.js"></script>
  <script type="text/javascript" src="../js/prism.min.js"></script>
  </div> <!-- body -->
</body>
</html>