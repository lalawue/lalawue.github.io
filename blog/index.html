<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>Sucha's Blog - Welcome</title>
    <meta name="generator" content="MarkdownProjectCompositor.lua" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="Sucha" />
    <meta name="keywords" content="suchang, programming, GNU, Linux, Emacs, Lua" />
    <meta name="description" content="Sucha's blog" />
    <link rev="made" href="mailto:suchaaa@gmail.com" />
    <link rel="shortcut icon" href="../images/ico.png" />
    <link rel="stylesheet" type="text/css" href="../styles/blog.css" />
    <link rel="stylesheet" type="text/css" href="../styles/prism.min.css" />
  </head>
  <body>
    <div id="body">
      <div id="text">
	   <!-- Page published by cmark-gfm begins here --><h1>Sucha's Blog ~ Welcome</h1><div class="date">22年4月5日 周六 01:28</div>
<h2>MoocHelper 更新到 0.2.12</h2>
<p>项目地址 <a href="https://github.com/lalawue/MoocHelper">MoocHelper</a>，同时更新了 .vsix 跨平台安装包。</p>
<p>因为 LuaHelper 前段时间更新了，我也跟着将基本的代码更新上去，这次改动主要是 anotation，语法方面我觉得没有什么变化。
anotation 我用得少，所以相关改变也说不上了解。</p>
<p>另外修复了 switch case 中 case 后面 exp 的一些解析问题，之前跟 Lua EBNF 表述的 prefixexp 语法 ':' 有冲突。</p>
<p>mooncake 里 case 紧接着的 exp 可以是右值，比如 object:func1(param1):func2(param2) 是一个合法的 Lua prefixexp，
而 case 语句依赖 ':' 作为终结符，由于 Lua 不依赖空格、分行、间距来作为语法分割，因此刚刚的 exp 对于两个不同的 ':' 可以有多种解释：</p>
<pre><code class="language-lua">-- case 1
case object:
    func1(param):func2(param2)
-- case 2
case object:func1(param1):
    func2(param2)
-- case 3
case (object:func1(param1):func2(param2))
</code></pre>
<p>实际上 Lua 的 prefixexp 使用的是贪心策略，最终解析出来的是 case 3，认为 case 子句没有完结，会报语法错误。
而 mooncake 之前对这里没有定义，因此 case 1 和 case 2 都是可选的合法解释。</p>
<p>这次的修改加上了补充，认为 ':' 之后如果紧接着空格，比如 '\t'、'\n'、'\t'、'\v'，则认为是 case 语句的终结。
因此 case 1、case 2 才是 mooncake 合法的 case 语句，并且语义有区别。而 case 3 并不是合法的语句。</p>
<p>大概这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2022-04.html#p0">Permalink</a></div>

<div class="date">22年3月29日 后日 22:54</div>
<h2>深圳停摆一周</h2>
<p>深圳因为疫情整个城市停摆了一周，我所在的小区因为有密接者检测出阳性，被封了两周。</p>
<p>密接者所在的楼栋，在被封锁的 2 周内足不出户，医护都是送吃的到户；我们这些顺带的，前面 4 天，足不出户，
但是可以点外卖，医护送外卖和快递到户，4 天之后可以自己下楼拿快递。</p>
<p>好不容易解封了，感觉自己胖了一圈。</p>
<p>这两周从足不出户、足不出楼、足不出小区走过来，真的挺痛苦的，因为小区有点小，人多，又不鼓励下楼到处转，憋得太慌了。</p>
<p>好在之前做了一些准备，即便不买外卖，自热饭够一周，加上囤的面，两三周都不成问题。就是吃得确实寒碜了点，肉类不够，蔬菜也不够。</p>
<p>我是中午点外卖，晚上换着吃自热饭、方便面、竹升面等，话说竹升面挺不错的，看起来小小一卷，煮开后足够我吃的，味道也不错，
面感挺好的，没有单独的包装这点不够好。</p>
<p>我是打算手头这些方便面吃完后，搞些其他的面食试一下，尝尝鲜，因为方便面多是油炸类型的，不够健康，而且味道类似，吃多了有点腻。</p>
<p>竹升面这类看似清淡，其实可以搭配的感觉要多很多，反正我都是会煮 2 ~ 3 分钟的，方面程度来说是一样的。</p>
<p>不大想煮饭，煮饭是好吃，只是时间上耗费太多，后面等条件好些，看看再煮饭吧。</p>
<div class="category"><a href="CategoryLife.html">CategoryLife</a> / <a href="2022-03.html#p0">Permalink</a></div>

<div class="date">22年2月27日 后日 23:24</div>
<h2>本站支持代码高亮</h2>
<p>用的方案是 <a href="https://prismjs.com/">Prism</a>，cmark-gfm 本来就支持生成相关的 pre、code tag，并带上 &quot;language-css&quot; 这样的 attribute 值，那只要简单加上下面两行就好了，在项目站点上，选了几个自己觉得也许会用得比较多的语言，比如 Bash/Shell/JS/Lua/Go/Swift/Lisp，我也就大概会这么多而已吧。</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../styles/prism.min.css&quot;&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prism.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>感觉效果很不错的，比如之前</p>
<ul>
<li><a href="../blog/2008-06.html#p1">Emacs-Lisp</a></li>
<li><a href="../blog/2021-11.html#p4">Javascript</a></li>
<li><a href="../blog/2021-11.html#p0">Ini</a></li>
<li><a href="../blog/2021-08.html#p0">Lua</a></li>
<li><a href="../blog/2020-12.html#p0">Swift</a></li>
<li><a href="../blog/2020-11.html#p0">Go</a></li>
<li><a href="../blog/2020-09.html#p1">Rust</a></li>
</ul>
<p>选的主题是 tomorrow night，跟已有的主题搭配起来也挺不错，缺点可能是 js 代码 minify 后仍然有 60k 吧。</p>
<p>不管怎么说，还有 Etag 撑着呢，另外，毕竟是存放在 github 的，算是白嫖了。</p>
<div class="category"><a href="CategoryThisSite.html">CategoryThisSite</a> / <a href="2022-02.html#p2">Permalink</a></div>

<div class="date">22年2月27日 周日 22:35</div>
<h2>MNet 支持 TLS 插件</h2>
<p>先说一下背景，<a href="https://github.com/lalawue/m_net/">mnet</a> 很早就想着加入 TLS 的支持，比如在做 cincau 或者 rpc_framework 的时候，就分别有作为独立 server 支持 https，以及作为 agent 使用内建的 TCP，去请求一个 https 认证的 API，或者拉取网页这样的要求。</p>
<p>但之前都是在 Lua/LuaJIT 这一层，在 C 之外做的 SSL 的状态管理，用起来不稳定，就放弃了，直接用了 curl。当时没有认真研究，自从考虑在 C 这一层，mnet 这一层加入 <a href="https://github.com/lalawue/m_net/tree/master/extension/openssl">TLS 插件</a> 后，之前不稳定的原因我终于找到了，这个后面再说。</p>
<p>先过一下 mnet 的插件系统，比如为什么要做成插件系统。</p>
<p>因为 mnet 本身是一个小型网络库，几乎是就是单文件支持 MacOS/Linux/FreeBSD/Windows，抽象了 epoll/kqueue/wepoll (IOCP epoll 化)，将 TLS 做成插件，是希望没有编译链接 TLS、OpenSSL 时，仍能独立支持 TCP、UDP。而加入 TLS、OpenSSL 的插件代码，以及相关编译选项后，提供 TLS 的支持，使用方式跟抽象为 chann 的普通 TCP 一样。</p>
<p>为了达成这一个目标，mnet 将插件接口抽象为基于 chann_type 的一种配置，mnet_core 单文件本身就提供了 TCP、UDP 的内建插件，外部只需要在 open_chann 时指定使用 TCP、UDP 接口，就能使用 core 提供的 chann listen、connect、send、recv API。</p>
<p>TLS 插件则是抽象 TLS 为一种外部定义的 chann_type，配置了这个定义后，TLS chann 使用方式跟 TCP、UDP 没有差别，从内部往外看，TLS chann_type 也是一种普通的 chann 而已，内部 core 对于所有类型的 chann_type，都提供同样能力的配置接口，没有特别对待。</p>
<p>所谓插件配置，其实就是抽象了 open_chann，listen_chann/connect_chann, send_chann/recv_chann, disconnect_chann/close_chann，chann_state 的回调函数，mnet 的插件，只要能提供 fd，以及这些插件接口，就可以利用上内部的 epoll、kqueue，以及 sending cache。</p>
<p>这样，外部建立 TLS chann，只需要指定 TLS chann_type，open 后做 listen/connect 就好，插件需要外部提供 SSL_CTX，因此证书管理是在外部的，网络无关的 API 内部没有引入。插件提供了 filter 接口，对于 epoll/kqueue 的读写事件，会 filter 询问 chann_type 对应的插件接口，是否要传递给外层调用的 API，还是插件还需要继续处理。</p>
<p>插件同样封装了 chann_state，这样 TLS 的状态可以有 CLOSE/DISCONNECT/CONNECTING/CONNECTED/LISTEN 了。</p>
<p>接着说一下之前在 Lua/LuaJIT 层为何基于 mnet 的 TCP 层做 SSL 没成功，仔细阅读 SSL_read/SSL_write 的 man page，可以看到这个接口接收到 buffer 读写命令后，底层仍然可能有重协商的逻辑，重协商的逻辑需要双方的数据传递，因此有可能需要先读取数据（协商相关的数据）才能写 buffer，反观 SSL_read 底层的重协商有可能先要写数据，才能读。</p>
<p>SSL_read/SSL_write 都有可能导致底层重协商，如果 fd 是阻塞的，协商结束，数据读、写成功后，才会返回给调用方；如果是非阻塞的 fd，ret 返回 &lt;= 0，需要调用 SSL_get_error(ret) 来获取是否是 SSL_ERROR_WANT_READ 或者 SSL_ERROR_WANT_WRITE，还是确实出错了，比如 SSL_ERROR_SSL 这种错误只有 SSL_shutdown，然后 close(fd) 了。</p>
<p>非阻塞 fd 导致的 WANT_READ 或 WANT_WRITE 的错误，需要调用方在合适的时机，使用同样的参数重新调用。说实话，看到这里，我总觉得这个 API 怎能这样设计，但是从 API 提供者的角度来说，非阻塞的 fd，需要打包额数据也许不足 ，也许干嘛干嘛，反正需要等待双方协商好后才能重新打包，如果传递过来的不是之前的数据，或者长度，又需要重新协商了。</p>
<p>为了方便调用方，SSL 提供了两个改善性的配置，一个是 SSL_MODE_ENABLE_PARTIAL_WRITE，只写一部分数据成功后，也返回了，再次发起 SSL_write 可以传递新的数据了，而不是整个 buffer 都成功才返回；另外一个是 SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER，意味着调用方可以换用 buffer 指针（内容、长度还需一致）。</p>
<p>之前 mnet 的 send 是有 cache 的，cache 长度是固定的，导致上面 SSL_write 这个接口不满足，长度变了，这次为了支持 TLS，一旦有 send 数据 cache，都是申请足量的内存 cache 住，后续 epoll/kqueue raise 了可以写的事件，在传递同样的内容、长度（仅 buffer 指针变化）给插件层的 send。</p>
<p>以上就解决了之前 Lua/LuaJIT SSL 不稳定的问题。</p>
<p>我自己是搞了自签名的证书、私钥测试了 reconnect 和 rwdata 这两个跟 TCP 一样的单点测试程序，算是通过了验收。因为 SSL_CTX 是外部提供的，因此后续的认证问题，应该不是问题，即便有特殊需要，基于插件的系统，应该可以可以回调解决吧，毕竟其实我也没有很重度使用这个插件的功能呢。</p>
<p>先这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2022-02.html#p1">Permalink</a></div>

<div class="date">22年2月10日 周二 00:56</div>
<h2>LuaRocks with LuaJIT (2)</h2>
<p>之前我还提到<a href="../blog/2020-07.html#p3">使用了 torch 的 LuaRock 方案</a>，但实际上不晓得 LuaRocks 在哪个版本起（至少在 3.7），编译的时候指定 Lua 解释器，就能直接支持，我其实已经用上很长时间了。</p>
<p>说实话，比较期待 LuaRocks 的方面是，直接根据依赖的 rocks，能够输出 single executable，虽然按照目前 LuaRocks 的 spec 构建描述，应该是很难的。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2022-02.html#p0">Permalink</a></div>

<div class="date">22年1月27日 周四 14:42</div>
<h2>MoocHelper</h2>
<p><a href="https://github.com/lalawue/mooncake">MoonCake</a> 终于有了支持 LSP 的 VSCode 插件
<a href="https://github.com/lalawue/MoocHelper">MoocHelper</a>，修改自 <a href="https://github.com/Tencent/LuaHelper">LuaHelper</a>，
一个基于 go 的 Lua LSP 方案。</p>
<p>话说 12 月底到 1 月中旬大部分的时间都在补充完善这个插件，基本功能两周之内的业余时间就搞定了。不得不说 go 确实比较简单，另外 LuaHelper 的代码结构也可圈可点，很好懂。</p>
<p>基本功能完成后，就开始了边用边改的流程，就这样又过了两周多，感觉配置好后，在 Mac 上的基本使用没啥问题了。</p>
<p>对比一下原版的功能，基本的代码补全，跳转，提示都是有的，只是缺少 debug 能力，因为 moocscript 是先翻译成 Lua 再交给 Lua 解释器的。另外，配置方面，修改了 luahelper.json 的读取路径，修改到了 .vscode/ 目录下。增加了配置项 ProjectLuaPath 以及 ProjectLuaCPath，对应工程使用的 LUA_PATH 和 LUA_CPATH 携带的路径列表。</p>
<p>增加了这两个配置后，浏览代码期间的环境变量跟运行时候就几乎是一样的了。</p>
<p>说到 Lua LSP 的方案选择，之前考虑过 <a href="https://github.com/sumneko/lua-language-server">sumneko/lua-language-server</a>，虽然我是 C/C++ 以及 Lua 都了解，但初步评估后，发现门槛有点高，不知道如何入手修改，以及 debug，想哭😭。</p>
<p>相比之下，基于 Go 的 LuaHelper，就太好 debug 了。只要按照 README 描述，在插件配置里面将选项 <code>connect lsp server way</code> 修改为 socket（默认是 cmd），而在另外一边的 luahelper-lsp 目录，按下 F5 就开启了调试模式，断点什么都特别方便。就算像我这样 go 基础非常浅的，也很快弄懂了如何 debug，几遍下来，程序的结构就很清楚了。</p>
<p>相比之下，lua-server 是 Lua + C++ 的方案，估计调试没那么容易，当然 go 的效率较高又是另外一个点了。</p>
<p>除此之外，我还看了一下相关的代码，知道其最终输出是 AST，后续的语法分析，提示、跳转什么都是依赖这个 AST 工作的，大概读懂这个 AST 结构后，我就比较放心了。moocscript 虽然语法不一样，但其最终会编译到 Lua，会沿用一样的 AST 结构，不会遗漏语言表达的任何细节。</p>
<p>一开始我想用 lua-server 的，但几遍下来，看不懂 parser 部分，没能抓住最后输出 AST 的逻辑，少了这个核心关键点，就只能放弃了。</p>
<p>也是基于上面输出同样 Lua AST 的原因，除了 debug 功能外，其他的功能，moocscript 和 lua 几乎是一样的，只是有一些限制。</p>
<p>这些限制是因为 Lua 和 MoonCake 在 token 阶段，共享了 token 这些关键字，moocscript 的关键字比 Lua 多了不少，这些关键字在 MoocHelper 里面的 Lua 文件也会被提示不能使用而报错，虽然 lua 解释器是能正常运行这些脚本的，这也算缺点之一吧。</p>
<p>对了，因为 AST 共通，所以 MoocHelper 也能解析 Lua 代码，工程里面不同文件，混用 moocscript 和 lua 都是没有问题的。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2022-01.html#p0">Permalink</a></div>

<div class="date">21年12月30日 周四 23:09</div>
<h2>鬼吹灯读后感</h2>
<p>不记得是月初还是上个月就看完了《鬼吹灯》，当然是全本，在微信阅读上看的，送了很多书币，断断续续就看完了。</p>
<p>共 232 章节，记得是中间那段还比较好看，前面略显沉闷，后面呢，感觉故事跟前面差不多，没有太多新意。</p>
<p>我自己对这个小说分类是穿越、惊悚类的探险小说，主要的场景是中国西北部、新疆、四川藏区的地域风情。故事里经常动不动就穿越了几千年，温存的场景少，打打杀杀、偷鸡摸狗的场景多，当然主角总是劫富济贫、危难中救人。</p>
<p>这个题材拍电影感觉会很好吧，鬼洞、鬼眼，以及蓝色的萤火虫鬼火，听到觉得挺吓人的了。</p>
<p>荒漠、戈壁、雪山下面探险，跟大粽子激斗，与狼王周旋，跟千年前的蛊术斗智斗勇，手中握着分金定穴的秘术，总是绝处逢生，但又被之前精绝古城的鬼眼、鬼洞病债，不得不到处寻方求生。</p>
<p>故事就是这样串联起来的吧。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2021-12.html#p0">Permalink</a></div>

<div class="date">21年11月30日 周二 21:24</div>
<h2>div 内容过长的显示</h2>
<p>js 入门的简单问题，我还是 baidu 了一下，花了一些时间，解决办法需要 CSS，设置 height 或者 max-height，然后设置 overflow 属性，如下</p>
<pre><code class="language-css">.code {
    max-height: 1024px;
    overflow: auto;
}
</code></pre>
<p>实际上，我是通过 js 来设置 docuementId 属性的，因为监听了 resize 事件，我觉得加了下面的函数更完善，可以根据可见区域到校重新 layout，如下：</p>
<pre><code class="language-js">window.addEventListener('resize', function(){
    if (document.body.clientWidth &lt; 1024) {
        document.getElementById('tag').removeAttribute('style');
    } else {
        document.getElementById('tag').setAttribute('style', 'max-height: ' + (document.body.clientHeight) + 'px;overflow:auto;');
    }
})
setTimeout(() =&gt; {
    var event = new Event('resize');
    window.dispatchEvent(event);
}, 1);
</code></pre>
<p>用了 setTimeout 来激活 resize，所以只需要设置一个 resize 监听就好，上面 js 意思是如果可见宽度 &lt; 1024，其实我是将其当成 phone 显示的，就不需要滚动条了。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-11.html#p4">Permalink</a></div>

<div class="date">21年11月25日 周四 22:51</div>
<h2>基于 luarocks/luastatic 的二进制打包工具</h2>
<p><a href="https://github.com/ers35/luastatic">luastatic</a> 可以打无依赖的二进制包，但是官方的版本有一些限制，比如在命令行里面，lua 源文件之只能是基于当前打包目录的相对路径。</p>
<p>而实际上，由于 lua 的 LUA_PATH、LUA_CPATH 以及 package.path 和 package.cpath 太自由，可以定制很多种搜索优先级，以及目录相对关系，打包目录下的相对路径，就不能反映源码上面的 require 路径逻辑了。</p>
<p>于是我基于上面的 luastatic，做了一点改进，可以输入相对路径，代码在 <a href="https://github.com/lalawue/luastatic">lalawue/luastatic</a>。</p>
<p>举个例子，一方面，我重度使用 luarocks 安装的库，比如 cincau，默认目录可以是 /usr/local/share/lua/5.1/cincau，而另外自己写的源码，都在 app 目录下，然后设置了如下的 LUA_PATH：</p>
<pre><code class="language-shell">$ export LUA_PATH=&quot;/usr/local/share/lua/5.1/cincau/?.lua;./app/?.lua&quot;
</code></pre>
<p>这样在 require 的时候，省却了很多相对路径。如果使用官方的 luastatic 打包，就得建立相对目录，然后作为命令行参数输入给 luastatic，用我修改后的 luastatic，只需要先设置 shell 变量：</p>
<pre><code class="language-shell">$ export LUASTATIC_SOURCE_PATH=&quot;/usr/local/share/lua/5.1/cincau/;app/;&quot;
</code></pre>
<p>注意目录最后的 '/' 和 ';'，如果输入的 lua 源文件检测到相应的路径前缀，会将这个前缀去掉，这样就实现了 LUA_PATH 和 package.path 的功能，运行时的路径搜索和打包时候的路径一致了，不需要构建相对目录。</p>
<p>另外需要注意的是，虽然 luastatic 支持生成无依赖的 binary，但那只是对应官方的 lua，luajit 依赖的 .so 库还是需要动态加载的，比如很多的 ffi.load 依赖的是系统的 dlopen。这个我看了一些文章，大佬们根据安全原则，系统的接口都不支持从内存中加载一个动态库，虽然某些平台上通过 mmap 是可以做到的，但是这个总感觉不大好。</p>
<p>那如果是基于 luajit，lua 源文件是打到 binary 里面了，但是依赖的 so 库，是在运行前，通过 export LD_LIBRARY_PATH 或者 DYLD_LIBRARY_PATH 来设置 so 搜索路径，做成外部库加载的。</p>
<p>通过这样的方式做成的 binary 发布包，可以在对应平台上不依赖 luarocks 就可以运行，安全性也好一些，发布更新都很方便。</p>
<hr />
<p>话说昨天看了一下 <a href="https://programming-language-benchmarks.vercel.app/">Programming Language and compiler Benchmarks</a> 里面 go vs java，go vs javascript 以及 go vs luajit，不得不说 go 性能确实好，速度跟 java 一样，但是内存消耗少了不知多少。</p>
<p>luajit 平均速度是 go 的一半，内存消耗多了一些，javascript 速度跟 luajit 类似，但内存消耗多很多。</p>
<p>如果是从头学起的话，我觉得 go 是要比 java 简单很多的，工程属性方面，go 更是标杆，如果算上多线程 goroutine 的话，毫无疑问，go 是首选。多线程多难搞呀，所以小公司很可能都慢慢转向 go 了，反正我是觉得真的香呀，现在都有点后悔搞 luajit 了，因为速度是赶不上 go 的，基础工具又差这么多。</p>
<p>上面的所谓打二进制包，就是补充了一部分基础工具的缺失，即便不说标杆 go，人家 deno 也是可以打成二进制包的。</p>
<p>luajit 不多的优点，一方面是不需要编译，虽然 go 编译很快，但是不需要编译连这个部分都省略了；另外就是 luajit 语法几乎是固定了，不大担心后续会有比较大的变动，唯一担心的额是 Mike Pall 是 luajit 几乎唯一的维护者，社区太小了，这个软件太高深，往后一些平台的支持以及升级估计够呛，更新也慢。</p>
<p>lua 语言的的优点在 web 开发上面不大体现得出来，相比之下，比如虚拟机很小，这样轻量的虚拟环境、沙箱，可以造就诸如国内有名的 <a href="https://github.com/cloudwu/skynet/">skynet</a>。</p>
<p>lua 语法更简单，类型都可以少关心，但并不意味说这个语言抽象能力不够，或者扩展不行，如果 metatable 抽象得好，可能性太多，OO 小菜一碟，比如我之前基于 lua 构建的 mooncake；所以，也没有泛型渴望症；但是因为缺乏类型系统，那么测试系统得自己保证才放心。话说，也是因为语言自由，lua 很多库的源码，相对 go 源码来说，可太难懂了。</p>
<p>最近还看了 WASM，感觉也很香，go 自从 1.11 后，支持输出 WASM，但 WASM 这个技术还比较早期，W3C 上面到了提案 2 的阶段，还没有多线程这样的标准。从上面效率对比，跟 go 是一个级别。</p>
<p>这次 post 先到这里吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-11.html#p3">Permalink</a></div>

<div class="date">21年11月17日 周三 21:52</div>
<h2>诛仙读后感</h2>
<p>以前没读过仙侠系列，算是第一次读。</p>
<p>前段意境真的很美，特别是上了青云山拜师之后，掌管大厨的这一段，跟师姐砍竹子，带领一猴一狗每天在这仙山里面慢慢悠悠升级，就觉得这感觉很好。</p>
<p>而且内线是有内功见长，又少不了武侠里面的捡到了绝世大宝贝，比如土到不能更土的烧火棍，以及后期那些救人于水火，法力无边的宝贝，更是让人羡慕神往。</p>
<p>起伏线的大起大落也很经典，以及一直不受师傅待见，但最后唯一一个给师傅长脸的徒弟，又比如被掌门下杀心的一段而成为鬼厉，从此杀人无数。</p>
<p>支线里面厉害的有万剑一，以及仙人指路，野狗跟仙人指路能走到一块，这个组合在人心里面又重了，这条线里面的仙人指路水平太高，应该是作者的用来补充剧情的旁白。</p>
<p>但是也有遗憾的支线，比较不能理解的是陆雪琪，一直走不到明线，但是暗线又这么强烈，难受。</p>
<p>前面写得太好了，觉得跟兽人大战之后，跟魔教对决的这一段，马马虎虎，没啥感觉。</p>
<p>总体可以打 7.5 ~ 8 分了。</p>
<div class="category"><a href="CategoryReading.html">CategoryReading</a> / <a href="2021-11.html#p2">Permalink</a></div>

<div class="date">21年11月11日 周四 00:33</div>
<h2>Mithril 使用心得（1）</h2>
<p>这个网站已经诞生 10 多年，但其是静态页面，基于 XHTML 结构，而不是最新的 HTML5，站长本人是专业 APP 开发，
H5/Web 开发比较业余，对 <a href="https://mithril.js.org/">Mithril</a> 的使用感觉还不够深入，但也算趟了一些坑，
可以作为心得说一下的。</p>
<p>说一下为何不使用 React、Vue 或者 Preact，以及 Angular 等等其他框架，没什么原因，因为其实入手之前看了非常多的入门对比文章，
在对比的过程中总是要上手的嘛，因为看到 Mithril 吹自己简单，其网站入门教程的介绍也是非常到位的（React 没能一下学会，
但是 Mithril 可以），加上不需要 nodejs 这样的依赖，不需要 build，学习的曲线感觉很平缓。</p>
<p>话说我之前是一个连 SPA（Single Page Application）都不懂的人，通过 Mithril 的教程，学会了基础的 component，
route、以及 XHR，基本上一个单页面就可以搞定了。</p>
<p>再说还有 <a href="https://stackblitz.com/">stackblitz</a> 这样的平台，入门是很方便的。因为是个无需 build 的方案，
简单的 HTML5 + rel 标签带入 Mithril 就可以开始工作了。</p>
<p>js 我也只懂皮毛，很多东西都得百度，没关系，出来的程序能用就行。最后做了 2 个 SPA 页面，一个是 wiki，一个是 note 便签。</p>
<p>wiki 的相对简单一些，大概 2 - 3 天才搞定，学习了 route，但是内部的很多状态我是通过一个全局状态变量来控制的。
便签这个页面没有用到路由，纯内部状态跳转刷新，两个都没有用到 browser 的 history，浏览器的返回按钮会退回上个 URL。</p>
<p>Mithirl 的 bind 或者 route，都可以仅指定页面的一个部分，一个 element 来刷新，内部是根据 vnode 的变化来判断是否更新的，
这个 vnode 变化感觉有点悬乎，比如我在创建一些子节点的时候，attribute 是有变化的，但是 Mithril 感觉不到这个变化，
所以我不得不在外层做更明显的 vnode 变化，比如增加一个用不到的 span 标签这样，来确保重新输出 HTML 节点。</p>
<p>Mithril 限定 60hz 刷新确实也不错，但是遇到一些极端情况，比如自己本地测试的时候，网络返回就挺快的，当我在用内部变量控制
vnode 输出的不同时，因为间隔过短，虽然变量有切换状态，但 Mithril 间隔读取到的其实都是同一个状态下的 vnode，
而忽略了中间这个变量状态下 vnode 的输出，最后导致认为没有变化，不需要刷新，出了问题，如下：</p>
<pre><code class="language-source">// 如下的 A、B 表示变量值，后面数字表示 vnode 结构为 A 但内容不同，这里需要保证 A1 -&gt; B 间隔 1/60 秒
A1 -&gt; B -&gt; A2
</code></pre>
<p>所以有时候，需要将一些操作延时到 60hz 单次刷新之外才行，让 Mithril 检测到 vnode 变化。</p>
<p>Mithril 教程用的是古老的创建 vnode 的函数调用方案，但其实可以配合 preact 的 <a href="https://github.com/developit/htm">htm</a>，
我觉得使用方式上要比教程里面的简单很多，比如教程是下面这样创建 vnode 的：</p>
<pre><code class="language-js">// 下面 title_str 是变量
// &lt;h1 class=&quot;title&quot;&gt;My first app&lt;/h1&gt;
const title_str = 'title';
m(&quot;h1&quot;, {class: title_str}, &quot;My first app&quot;)
</code></pre>
<p>如果用了 <a href="https://github.com/developit/htm">htm</a>，可以像下面这样：</p>
<pre><code class="language-js">// 先绑定，最后也是通过 m 函数来输出 vnode 的
const html = htm.bind(m);
const title_str = 'title';
html`&lt;h1 class=&quot;${title_str}&quot;&gt;My first app&lt;/h1&gt;`
</code></pre>
<p>明显是使用了 htm 的代码更容易定位问题。</p>
<p>因为追求短平快，单个 js 文件就完成了 wiki 或者 note 便签这样的功能，所以 Mithril 结构化方面我是没有发言权了，教程上面
呼吁结构化组件，分解功能模块我是一点都没用上。</p>
<p>先这样吧。</p>
<div class="category"><a href="CategoryProgramming.html">CategoryProgramming</a> / <a href="2021-11.html#p1">Permalink</a></div>
<!-- Page published by cmark-gfm ends here -->
  <div id="foot">2004-<script type="text/javascript">var d = new
	Date();document.write(d.getFullYear())</script> &copy;
	Sucha. Powered by MarkdownProjectCompositor.
  </div>
  </div><!-- text -->
  <div id="sidebar">
  </div><!-- sidebar -->
  <script type="text/javascript" src="../js/blog_sidebar.js"></script>
  <script type="text/javascript" src="../js/prism.min.js"></script>
  </div> <!-- body -->
</body>
</html>